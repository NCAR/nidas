#!/bin/bash
### BEGIN INIT INFO
# Provides:          emerald
# Required-Start:    $local_fs $network $syslog
# Required-Stop:     $local_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Load kernel module for Emerald serial card, create its device files
# Description:       Diamond Systems Emerald is an 8-port PC104 serial communications card.
#                    The emerald kernel module provides a device interface for each card.
#                    After loading the kernel module, this script creates up a /dev/emeraldN
#                    device for each card, executes the set_emerald program to set
#                    the ISA ioport and interrupts for each serial port on the card, and then
#                    runs setserial to configure the 8 serial ports, /dev/ttySn,
#                    for the stock 8250 serial driver. Digital I/O devices, /dev/ttyDn,
#                    are also created for each port, which can be accessed with the emerald_dio
#                    program to control the 8 digital I/O lines on the Emerald.
### END INIT INFO

# Note we're using the evil bash!  This script uses bash arrays.

# Author: Gordon Maclean <maclean@ucar.edu>

# Do NOT "set -e"

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/opt/nidas/bin
DESC="emerald initialization"
NAME=emerald
MODULE=emerald
SCRIPTNAME=/etc/init.d/$NAME

# Exit if the package is not installed
[ -e "/lib/modules/$(uname -r)/nidas/$NAME.ko" ] || exit 0
[ -x "/opt/nidas/bin/set_emerald" ] || exit 0

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
. /lib/lsb/init-functions

# On some PXA CPUs the ISA interrupts are mapped to other numbers,
# in which case these should be the actual IRQs for the ISA interrupts, 0-15.
isairqs=(0 0 0 3 4 5 6 7 0 9 10 11 12 0 14 15)

# For whatever reason, if CK is not installed, then set baud_base=460800.
# Haven't tested what one should use if CK is installed.
# baud_base=115200
baud_base=460800

# default configuration of first 4 boards
defports=(0x100 0x140 0x180 0x1c0)
defirqs=(3 4 5 6)

devdir=/dev

NBOARDS=0

#
# load the emerald kernel module
#
modprobe_emerald()
{
        if ! modprobe $NAME; then       # returns 0 is already loaded
            depmod -a
            modprobe $NAME || return 2
        fi
        RETVAL="$?"
        return "$RETVAL"
}

#
# unload the emerald kernel module
#
rmmod_emerald()
{
        lsmod | fgrep -q $NAME || return 1
        rmmod $NAME
        RETVAL="$?"
        return "$RETVAL"
}

#
# Create emerald0 device on /dev
#
create_emerald() {
        modprobe_emerald || return 1
        emajor=$(fgrep emerald /proc/devices | head -n 1 | cut -d\  -f1)
        rm -f $devdir/emerald0
        mknod $devdir/emerald0 c $emajor 0
        chmod 0666 $devdir/emerald0
        return 0
}

get_isabase() {
        # ISA base address on system.
        # Titan kernel has been updated so that this is 0, 
        set_emerald -b $devdir/emerald0 || echo -1
}

get_nboards() {
        create_emerald || return 2
        # number of boards with acceptable config in eeprom
        NBOARDS=$(set_emerald -n $devdir/emerald0 || echo -1)
        [ $NBOARDS -lt 0 ] && return 2

        # Create /dev/emeraldN for each board
        local eminor=0
        local brd
        for (( brd = 0; brd < $NBOARDS; brd++ )); do
                local emdev=$devdir/emerald$brd
                if ! [ -c $emdev ]; then
                    mknod $emdev c $emajor $eminor
                    chmod 0666 $emdev
                fi
                # increment eminor by number of uart ports
                while read portstr port irqstr irq; do
                        case "$irqstr" in
                        irq)
                                let eminor++
                                ;;
                        esac
                done < <(set_emerald $emdev)
        done
        return 0
}

check_ports() {
        local result=0
        local -a ports=()
        local -a irqs=()
        local -a birqs=()
        for (( brd = 0; brd < $NBOARDS; brd++ )); do
                local emdev=$devdir/emerald$brd
                local birq=-1

                # read ioport and irq configuration
                while read portstr port irqstr irq; do
                        case "$irqstr" in
                        irq)
                                portval=$(( $port ))
                                # valid port addresses are 0x100 to 0x3f8 (256-1016)
                                # If not in this range then there isn't a board at this
                                # address.
                                if [ $portval -ge 256 -a $portval -le 1016 ];then
                                        # If a duplicate ioport address is found, report the error.
                                        if echo ${ports[*]} | fgrep -q $port; then
                                                echo "Duplicate port=$port on $emdev"
                                                result=1
                                                break
                                        fi
                                        [ $birq -lt 0 ] && birq=$irq
                                        if [ $birq -ne $irq ]; then
                                                echo "irq=$irq on $emdev, port $port does not match board irq=$birq"
                                                result=1
                                                break
                                        fi
                                        # Also don't share interrupts across boards
                                        if echo ${birqs[*]} | fgrep -q $birq; then
                                                echo "Duplicate irq=$irq on $emdev, port $port"
                                                result=1
                                                break
                                        fi
                                        ports=(${ports[*]} $port)
                                fi
                                # echo ${ports[*]}
                                ;;
                        esac
                done < <(set_emerald $emdev)
                birqs[$brd]=$irq
                # If OK, enable the ports on the board
                [ $result -eq 0 ] && set_emerald -u $emdev || return 1
        done
        return $result
}

# Set register configuration on Emerald board to default values
default_config()
{
        for (( brd = 0; brd < $NBOARDS; brd++ )); do
                emdev=$devdir/emerald$brd
                echo "doing: set_emerald $emdev ${defports[$brd]} ${defirqs[$brd]}"
                set_emerald $emdev ${defports[$brd]} ${defirqs[$brd]} > /dev/null
                # enable the ports after configuring them.
                set_emerald -u $emdev || return 1
        done
}

create_ports()
{
        baseaddr=$((`get_isabase`)) # convert to numeric
        if [ $baseaddr -lt 0 ]; then
            echo "ISA base address not known"
            return 1
        fi
        # Create /dev/ttySN files and do setserial on them
        # First available ttyS port on Viper
        ttynum=5
        # major and minor number of ttyS5
        tmajor=4
        tminor=69
        # minor number of emerald devices
        eminor=0
        for (( brd = 0; brd < $NBOARDS; brd++ )); do
                emdev=$devdir/emerald$brd

                # read ioport and irq configuration
                while read portstr port irqstr irq; do
                        case "$irqstr" in
                        irq)
                                portval=$(($port))
                                if [ $portval -ge 256 -a $portval -le 1016 ]; then
                                        ttydev=$devdir/ttyS$ttynum
                                        if ! [ -c $ttydev ]; then
                                            mknod $ttydev c $tmajor $tminor
                                            chmod 0666 $ttydev
                                        fi

                                        # device for accessing the digital out pin
                                        # associated with a port on the emerald
                                        diodev=$devdir/ttyD$ttynum
                                        if ! [ -c $diodev ]; then
                                            mknod $diodev c $emajor $eminor
                                            chmod 0666 $diodev
                                        fi

                                        portstr=`printf "%#x" $(( $baseaddr + $port ))`
                                        nirq=${isairqs[$irq]}
                                        # Aug 2012, kernel 2.6.35, tried the low_latency setserial option.
                                        # See comment in isff-etc/etc/serial.conf
                                        setserial -zvb $ttydev port $portstr irq $nirq baud_base $baud_base autoconfig
                                        let tminor++
                                        let ttynum++
                                fi
                                let eminor++
                                ;;
                        esac
                done < <(set_emerald $emdev)
        done
        return 0
}

do_start()
{
        # Return
        #   0 if daemon has been started
        #   1 if daemon was already running
        #   2 if daemon could not be started
        get_nboards
        RETVAL="$?"
        [ $RETVAL -eq 2 ] && return "$RETVAL"
        check_ports || default_config || return 2
        create_ports || return 2
        return 0
}

#
# Function that stops the daemon/service
#
do_stop()
{
	# Return
	#   0 if daemon has been stopped
	#   1 if daemon was already stopped
	#   2 if daemon could not be stopped
	#   other if a failure occurred
        rmmod_emerald
        RETVAL="$?"
        return "$RETVAL"
}

#
# Function that sends a SIGHUP to the daemon/service
#
do_reload() {
	#
	# If the daemon can reload its configuration without
	# restarting (for example, when it is sent a SIGHUP),
	# then implement that here.
	#
	start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME
	return 0
}

case "$1" in
  start)
	[ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
	do_start
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  stop)
	[ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
	do_stop
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  status)
        modprobe $NAME && exit 0 || exit $?
	;;
  #reload|force-reload)
	#
	# If do_reload() is not implemented then leave this commented out
	# and leave 'force-reload' as an alias for 'restart'.
	#
	#log_daemon_msg "Reloading $DESC" "$NAME"
	#do_reload
	#log_end_msg $?
	#;;
  restart|force-reload)
	#
	# If the "reload" option is implemented then remove the
	# 'force-reload' alias
	#
	log_daemon_msg "Restarting $DESC" "$NAME"
	do_stop
	case "$?" in
	  0|1)
		do_start
		case "$?" in
			0) log_end_msg 0 ;;
			1) log_end_msg 1 ;; # Old process is still running
			*) log_end_msg 1 ;; # Failed to start
		esac
		;;
	  *)
		# Failed to stop
		log_end_msg 1
		;;
	esac
	;;
  *)
	#echo "Usage: $SCRIPTNAME {start|stop|restart|reload|force-reload}" >&2
	echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload}" >&2
	exit 3
	;;
esac

:
