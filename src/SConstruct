# -*- python -*-
##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

import re
from SCons.Script import Environment, SConscript, BoolVariable, EnumVariable
from SCons.Script import COMMAND_LINE_TARGETS
import eol_scons

eol_scons.EnableInstallAlias(False)

# eol_scons.debug.SetDebug("true")
#
# Don't load tools that perform compiler or pkg-config checks until the cross
# tool is loaded, PKG_CONFIG_PATH is set, and the custom config filename
# nidas.conf can be set.
env = Environment(tools=['default'], toolpath=['#/tools'])

# This passes all settings from the calling environment.  This was a quick fix
# for supercomputer builds (casper) which use modules to setup the environment,
# to pull in specific sets and versions of tools and libraries. It is left here
# disabled as a placeholder until it's needed again and a less heavy-handed
# approach can be found.
if False:
    env.PassEnv('')

# Create the eol_scons global variables and the NIDAS variables from the
# same config file.
opts = eol_scons.GlobalVariables('nidas.conf')
opts.AddVariables(('PREFIX',
                   'installation path',
                   '/opt/nidas', None, eol_scons.PathToAbsolute))

# Only one target architecture can be built in a single scons run, but each
# target uses a different variant build dir.
opts.Add(EnumVariable('ARCH',
"""
 Architecture to build and install.  'host' is a native build, everything else
 requires a cross-compiler.
""",
         'host', allowed_values=('host', 'arm', 'armbe', 'armel', 'armhf')))

opts.Add('BUILDS', 'Backwards-compatible alias for ARCH, deprecated.')

opts.Add(EnumVariable('MACH',
"""
 Name of target machine for the architecture in ARCH, for building and
 installing machine-specific code, such as kernel modules.  If not specified,
 then a default is chosen among the targets for the given ARCH.
""",
         None, allowed_values=('host', 'viper', 'vulcan', 'titan', 'rpi2', 'rpi3')))
opts.Add('MACHS', 'Backwards compatible alias for MACH, deprecated.')

opts.Add(BoolVariable('DEBUG', 'Define DEBUG symbol.', 'off'))
opts.Add(BoolVariable('GDBDEBUG', 'Enable -ggdb flag.', 'off'))
opts.Add(BoolVariable('ENABLE_VALGRIND',
                      'Enable valgrind run-time hints.',
                      'off'))
opts.Add(BoolVariable('LINUX_MODULES', 
                      'Build linux modules when possible.', 'on'))
opts.Add('REPO_TAG',
"""
 git tag of the source, in the form "vX.Y", when building outside of a git
 repository
""")
opts.Add('PKG_CONFIG_PATH',
"""
 Path to pkg-config files, if you need other than the system default
""")

# Generally can let this default to the values set below.
# For x86_64 builds it defaults to 'lib64'. When building
# a Debian package for x86_64 (amd64), the Makefile that calls
# scons pre-sets it to lib/x86_64-linux-gnu to be similar with
# the arm libs and be more Debian-multiarch-like.
opts.Add('ARCHLIBDIR', '\n'
         '  Where to install NIDAS libraries relative to $PREFIX', None)

opts.Update(env)
env.Tool('gitinfo')

# Threads
env.MergeFlags('-pthread')

if 'PKG_CONFIG_PATH' in env:
    env.PrependENVPath('PKG_CONFIG_PATH', env['PKG_CONFIG_PATH'])

# Here are the supported build targets, expressed in the form arch-machine,
# which loosely follows the GNU GCC machine configuration name of
# arch-company-system, where system is implied to be linux.  Only one of these
# targets can be built in a single scons build.

def check_target(env):
    """
    Check that the ARCH and MACH settings match a supported target, and handle
    backwards compatibility with BUILDS and MACHS.
    """
    # dictionary of arch-mach pairs which map to a tuple of (arch, mach)
    targets = {
        'arm-viper': ('arm', 'viper'),
        'arm-titan': ('arm', 'titan'),
        'armbe-vulcan': ('armbe', 'vulcan'),
        'armel-titan': ('armel', 'titan'),
        'armel-viper': ('armel', 'viper'),
        'armhf-rpi2': ('armhf', 'rpi2'),
        'armhf-rpi3': ('armhf', 'rpi2'), # until there's a difference
        'host-host': ('host', 'host')
    }
    arch = env.get('ARCH') or env.get('BUILDS')
    mach = env.get('MACH') or env.get('MACHS')
    if not mach:
        # find a default machine matching against just the arch.
        machs = [m for a, m in targets.values() if a == arch]
        mach = machs[0]
    name = f"{arch}-{mach}"
    target = targets.get(name)
    if not target:
        raise Exception(f'target {name} is not a supported target')
    env['ARCH'] = arch
    env['MACH'] = mach
    # 'TARGET' is a reserved variable in SCons
    env['NIDAS_TARGET'] = name


check_target(env)

ARCH = env['ARCH']
MACH = env['MACH']

env.PrintProgress(f"Setting up for {ARCH} build, {MACH} target machine...")

# NIDAS uses PREFIX as the root install prefix, but since it's a
# Variable that SCons sets, that means it should only have one value
# for the entire build rather than be modified for each variant build.
# So the arch-specific prefix is stored in the ARCHPREFIX variable,
# and it defaults to just PREFIX.  This way there can be an
# arch-specific install location which gets built up from the main
# PREFIX.
#
# Targets which should be installed in arch-specific locations should
# use ARCHPREFIX, while targets which are not arch-specific can go
# under PREFIX.  For native host builds, they will be the same.
env['ARCHPREFIX'] = '$PREFIX'

# env['CXX'] = 'clang++'
env['CFLAGS'] = ['-Wall','-O2']
env['CXXFLAGS'] = ['-Wall', '-O2']
if env['CXX'] == 'clang++':
    # Someday it might be nice to refactor the remaining overloaded virtual
    # functions, but for now they're working and haven't seemed to bite us yet.
    env.AppendUnique(CXXFLAGS=['-Wno-overloaded-virtual'])
    # Ignore inconsistent overrides to add them piecemeal.
    env.AppendUnique(CXXFLAGS=['-Wno-inconsistent-missing-override'])
    # env.AppendUnique(CXXFLAGS=['-stdlib=libstdc++'])
    # env.AppendUnique(LDFLAGS=['-rtlib=libgcc'])

if env.get('DEBUG'):
    env.AppendUnique(CPPDEFINES=['DEBUG'])

env['CCFLAGS'] = []
if env.get('GDBDEBUG'):
    env.AppendUnique(CCFLAGS=['-ggdb'])

##
##  Install firmware
##
SConscript("firmware/anythingIO/SConscript", exports={'env': env})

##
##  Install a2d filters
##
SConscript("../filters/SConscript", exports={'env': env})


def get_variant_dir(env):
    """
    Derive the variant build dir for the arch and mach of the given
    environment.
    """
    arch = env.get('ARCH')
    mach = env.get('MACH')
    vdir = "build"
    if arch and arch != 'host':
        vdir += "_" + arch
    if mach and mach != 'host':
        vdir += "_" + mach
    return vdir


env.Tool(f'nidas_{ARCH}')
env.Require(['symlink', 'sharedlibrary', 'stackprotector'])

if not env.get('DEBUG'):
    env.AppendUnique(CPPDEFINES = ['NDEBUG'])

env['VARIANT_DIR'] = env.Dir('#/' + get_variant_dir(env))

SConscript('nidas/SConscript', variant_dir=env['VARIANT_DIR'],
           duplicate=1, exports={'env': env})

# need at least one default target, else scons will build everything.  this
# makes the default everything built into the variant dir.
env.Default(get_variant_dir(env))

if ARCH == 'host' and env.File("tests/SConscript").exists():
    # Testing targets, built and run only on host. When building packages,
    # it is not even in the source tree.
    SConscript("tests/SConscript", exports={'env': env})

# Install the schema where it can be referenced globally on the system.
env.Alias('install', env.Install('$PREFIX/share/xml','#xml/nidas.xsd'))

dox = env.Command('#/../doc/doxygen',
              '#/../doc/doxygen_conf/nidas.doxy',
              'cd .. && rm -rf doc/doxygen && ( cat $SOURCE; echo PROJECT_NUMBER=$REPO_TAG ) | doxygen -')
env.Alias('dox', dox)
env.AlwaysBuild(dox)

# Use InstallAs to $PREFIX/doxygen.  Do not install docs unless explicitly
# requested, so that --install-sandbox does not automatically install the docs
# with the other install targets.
if 'doxinstall' in COMMAND_LINE_TARGETS:
    env.Alias('doxinstall',
              env.InstallAs('$PREFIX/doxygen','#/../doc/doxygen'))

# Use the eol_scons SetHelp() method to generate all the help text,
# including the directory of aliases, but then append a custom summary of
# nidas targets.
env.SetHelp()
nidas_help = """
Main Targets (use -c to clean targets):

 (none)     -- build libraries, executables and kernel modules for native system.
 host       -- build libraries, executable programs and modules for host system.
 arm        -- build libraries, executables and kernel modules for Eurotech Viper 
               and Titan, running (obsolete) Arcom Embedded Linux
 armbe      -- build libraries, executables and kernel modules for Eurotech Vulcan, 
               running Arcom Embedded Linux
 armel      -- build libraries, executables and kernel modules for Eurotech Viper 
               and Titan, Debian 8
 armhf      -- build libraries, executables and kernel modules for ARMv6/7 systems, 
               such as R Pi2, running Raspian
 install    -- build and install all modules, libraries, headers and executables.
 -c install -- clean targets from $PREFIX
"""
env.AddHelp(nidas_help)
