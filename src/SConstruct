# -*- python -*-
##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

import os, re
import eol_scons

# Create the eol_scons global variables and the NIDAS variables from the same config file.
gopts = eol_scons.GlobalVariables('nidas.conf')
opts = Variables('nidas.conf')
opts.AddVariables(('PREFIX',
                   'installation path',
                   '/opt/nidas', None, eol_scons.PathToAbsolute))

#  Create construction environment with user's PATH.
env = Environment(ENV = {'PATH' : os.environ['PATH']},
    tools=['default','svninfo'])

opts.AddVariables(('OTHER_PREFIX',
                   'Optional prefix for other dependencies.',
                   '$PREFIX', None, eol_scons.PathToAbsolute))

opts.Add('BUILDS',
         'Space-separated list of architectures to build and install: host, arm or armbe.',
         'host arm armbe')

opts.Add('MACHS',
         'Space-separated list of machine names for the architecture (viper, vulcan, titan or all), for building and installing machine-specific code, such as kernel modules.',
         'all')

opts.Add(BoolVariable('DEBUG', 'Define DEBUG symbol.', 'off'))
opts.Add(BoolVariable('XMLDEBUG', 'Enable the XML_DEBUG definition.',
                      'off'))
opts.Add(BoolVariable('GDBDEBUG', 'Enable -ggdb flag.', 'off'))
opts.Add(BoolVariable('PSQL_ENABLE', 'Build PSQL modules when detected.', 
                      'off'))
opts.Add(BoolVariable('LINUX_MODULES', 
                      'Build linux modules when possible.', 'on'))

# Use PREFIX to generate defaults for the OTHER prefixes, so the OTHER
# prefixes will just be redundant if not specified.  Don't add the other
# options at all unless the corresponding build architecture is selected.

opts.Update(env)
BUILDS = Split(env['BUILDS'])
MACHS = Split(env['MACHS'])

if 'host' in BUILDS or 'x86' in BUILDS:
    opts.Add('KERNELDIR', 'path to linux kernel source for build host, (use * for /usr/src/kernels/`uname -r`[-`uname -m`]:','*')

if 'arm' in BUILDS:
    opts.Add('KERNELDIR_viper', 'path to linux kernel source for Viper:',
             '/opt/arcom/src/linux-source-2.6.16.28-arcom1')
    opts.Add('KERNELDIR_titan', 'path to linux kernel source for Titan:',
             '/opt/arcom/src/linux-source-2.6.20.18-ael4')

if 'armbe' in BUILDS:
    opts.Add('KERNELDIR_vulcan', 'path to linux kernel source for Vulcan:',
             '/opt/arcom/src/linux-source-2.6.21.7-ael1')

opts.Update(env)

##
##  Define compiler flags and paths for all builds.
##
# scons man page:
# CFLAGS
#   General  options  that  are  passed  to the C compiler
#   (C only; not C++).
# CCFLAGS
#   General options that are passed to the C and C++  compilers.
# CXXFLAGS
#   General  options that are passed to the C++ compiler.  By
#   default, this includes the value  of  $CCFLAGS,  so  that
#   setting  $CCFLAGS affects both C and C++ compilation.  If
#   you want to add C++-specific flags, you must set or over-
#   ride the value of $CXXFLAGS.
#
# Warning: CXXFLAGS is before CCFLAGS in the compiler arguments:
# print 'CXXCOM=' + str(env['CXXCOM'])
# CXXCOM=$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES
#
# compiler string for building shareable code:
# print 'SHCXXCOM=' + str(env['SHCXXCOM'])
# SHCXXCOM=$SHCXX -o $TARGET -c $SHCXXFLAGS $SHCCFLAGS $_CCCOMCOM $SOURCES
#
# Because of the ordering, it isn't possible to add a CXX-only option
# at the end of the flags. Hence, don't put options in CCFLAGS that
# you may want to override for CXX.  For example:
# CCFLAGS='-Wall',  CXXFLAGS='-Wno-uninitialized', will result in
# -Wno-uninitialized -Wall, not the other way around.

# print 'CFLAGS=' + str(env['CFLAGS'])
# print 'CCFLAGS=' + str(env['CCFLAGS'])
# print 'SHCCFLAGS=' + str(env['SHCCFLAGS'])
# print 'CXXFLAGS=' + str(env['CXXFLAGS'])
# print 'SHCXXFLAGS=' + str(env['SHCXXFLAGS'])

env['CFLAGS'] = [ '-Wall','-O2' ]
env['CXXFLAGS'] = [ '-Wall','-O2' ]

env['CCFLAGS'] = [ ]

if env.has_key('XMLDEBUG') and env['XMLDEBUG']:
    env.AppendUnique(CPPDEFINES = ['XML_DEBUG'])

if env.has_key('DEBUG') and env['DEBUG']:
    env.AppendUnique(CPPDEFINES = ['DEBUG'])

if env.has_key('GDBDEBUG') and env['GDBDEBUG']:
    env.AppendUnique(CCFLAGS = ['-ggdb'])

env.Append(SHLIBMAJORVERSION = '1')
env.Append(SHLIBMINORVERSION = '0')
env.Append(USE_ARCHLIBDIR = 1)

infos = [env.SvnInfoBuilder("#/nidas/core/SvnInfo.h",["#/nidas"]),
    env.SvnInfoBuilder("#/nidas/linux/SvnInfo.h",["#/nidas/linux"])]

##
##  Install firmware
##
SConscript("firmware/anythingIO/SConscript",exports={'env':env})

##
##  Install a2d filters
##
SConscript("../filters/SConscript",exports={'env':env})

##
##  Create the env for building to the host processor...
##
if 'host' in BUILDS or 'x86' in BUILDS:
    print "Setting up for host builds..."
    host_env = env.Clone(tools = ['symlink','sharedlibrary'],
        ARCH = '',
        MACHS = [''],
    )

    host_env.AppendUnique(CCFLAGS = ["-g"])
    host_env.AppendUnique(CXXFLAGS = ['-Wextra','-Weffc++'])
    exports = {'env':host_env}

    SConscript('nidas/SConscript',
               variant_dir='build',
               duplicate=0, exports=exports)
    Alias('host','build')
    Clean('host','build')
    Alias('x86','build')
    Clean('x86','build')

    # Testing targets, built and run only on host
    SConscript("tests/goes_dcp/SConscript",exports=exports)
    SConscript("tests/iterators/SConscript",exports=exports)
    SConscript("tests/serial_sensor/SConscript",exports=exports)
    SConscript("tests/tlogger/SConscript",exports=exports)
    SConscript("tests/tiostream/SConscript",exports=exports)
    SConscript("tests/network/SConscript",exports=exports)
    SConscript("tests/sync_server_dump/SConscript",exports=exports)
    SConscript("tests/ck_xml/SConscript",exports=exports)
    SConscript("tests/UTime/SConscript",exports=exports)

##
##  Create the env for cross-building to the xScale ARM processor
##  (little-endian) on the arcom Viper and Titan.
##
if 'arm' in BUILDS:
    print "Setting up for arm build ..."

    # supported machine types for arm
    amachs = { 'all': ['viper','titan'], 'viper':['viper'], 'titan': ['titan']}
    # build list of machine types to build from MACHS="x y z" command line
    machs = []
    for m in MACHS:
        if amachs.has_key(m):
            machs.extend(amachs[m])
    machs = list(set(machs))    # unique-ify

    arm_env = env.Clone(tools = ['armcross','symlink','sharedlibrary'],
        ARCH = 'arm',
        MACHS = machs,
        PREFIX = env['PREFIX'] + '/arm'
    )
    # g++ version 3.4.4 often gives false positives when
    # trying to detect uninitialized variables.
    if re.search("^3",arm_env['CXXVERSION']):
        arm_env.AppendUnique(CXXFLAGS = ['-Wnon-virtual-dtor','-Wno-uninitialized'])
    if not arm_env.has_key('DEBUG') or not arm_env['DEBUG']:
        arm_env.AppendUnique(CPPDEFINES = ['NDEBUG'])

    arm_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')
    SConscript('nidas/SConscript',
               variant_dir='build_arm',
               duplicate=0, exports={'env':arm_env})
    Alias('arm','build_arm')
    Clean('arm','build_arm')

##
##  Create the env for cross-building to the xScale ARM processor
##  (big-endian) on the arcom Vulcan.
##
if 'armbe' in BUILDS:
    print "Setting up for armbe build ..."

    # supported machine types for armbe
    amachs = { 'all': ['vulcan'], 'vulcan':['vulcan']}
    # build list of machine types to build from MACHS="x y z" command line
    machs = []
    for m in MACHS:
        if amachs.has_key(m):
            machs.extend(amachs[m])
    machs = list(set(machs))    # unique-ify

    armbe_env = env.Clone(tools = ['armbecross','symlink','sharedlibrary'],
        ARCH = 'armbe',
        MACHS = machs,
        PREFIX = env['PREFIX'] + '/armbe',
    )
    armbe_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')

    if re.search("^3",armbe_env['CXXVERSION']):
        armbe_env.AppendUnique(CXXFLAGS = ['-Wnon-virtual-dtor','-Wno-uninitialized'])
    if not armbe_env.has_key('DEBUG') or not armbe_env['DEBUG']:
        armbe_env.AppendUnique(CPPDEFINES = ['NDEBUG'])

    SConscript('nidas/SConscript',
               variant_dir='build_armbe',
               duplicate=0, exports={'env':armbe_env})
    Alias('armbe','build_armbe')
    Clean('armbe','build_armbe')


Default([BUILDS,infos])

# Install the schema where it can be referenced globally on the system.
Alias('install',
      Alias('xml_install',
            env.Install('$PREFIX/share/xml','#xml/nidas.xsd')))

Alias('install',
      Alias('scripts_install',
            env.Install('$PREFIX/bin','#scripts/nidas_rpm_update.sh')))

dox = Command('#/../doc/doxygen/html/index.html',
              '#/../doc/doxygen_conf/nidas.doxy',
              'cd .. && doxygen $SOURCE')
Alias('dox', dox)
AlwaysBuild(dox)

opts.Update(env)
gopts.Update(env)
Help(opts.GenerateHelpText(env) + gopts.GenerateHelpText(env) + """
targets (use -c to clean targets)
(none) build libraries, executables and kernel modules for ARM, ARMBE, & native systems.
host    build libraries, executable programs and modules for host system.
arm    build libraries, executables and kernel modules for Eurotech Viper and Titan.
armbe  build libraries, executables and kernel modules for Eurotech Vulcan.
install build and install all modules, libraries, headers and executables.
-c install  clean targets from $PREFIX
""")

