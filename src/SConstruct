# -*- python -*-
##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

import os,re

##
##  Create a new construction environment variable and
##  restrict it's build methods to be POSIX based only.
##
env = Environment(platform = 'posix',
    ENV = {'PATH' : os.environ['PATH']},
    tools=['default','svninfo'])

# Grab the runstring variables, put in environment.
opts = Variables('nidas.conf')
opts.AddVariables(
    PathVariable('PREFIX',
               'installation paths: $PREFIX/x86, $PREFIX/arm, $PREFIX/armbe, $PREFIX/share',
               '/opt/local/nidas', PathVariable.PathAccept))

# Path to RAF headers and libraries
if os.environ.has_key('JLOCAL'):
    jlocal = os.environ['JLOCAL']
else:
    jlocal = '/opt/local'

opts.AddVariables(
    PathVariable('JLOCAL',
               'path to RAF headers and libraries',
               jlocal, PathVariable.PathAccept))

opts.AddVariables(
    PathVariable('QT4DIR',
       'Parent directory of qt4 bin, include and lib sub-directories. Default locations of these are determined from "which" and pkg-config commands and so QT4DIR typically does not need to be specified.', 
       None, PathVariable.PathAccept))

opts.AddVariables(
    PathVariable('OTHER_PREFIX',
               'Optional prefix for other dependencies.',
               '$PREFIX',PathVariable.PathAccept))

opts.Add('BUILDS',
         'Space-separated list of architectures to build and install.',
         'x86 arm armbe')

opts.Add('MACHS',
         'Space-separated list of machine names (x86,viper,vulcan,titan or all), for building and installing machine-specific code, such as kernal modules.',
         'all')

opts.Add(BoolVariable('DEBUG', 'Define DEBUG symbol.', 'off'))
opts.Add(BoolVariable('XMLDEBUG', 'Enable the XML_DEBUG definition.',
                      'off'))
opts.Add(BoolVariable('GDBDEBUG', 'Enable -ggdb flag.', 'off'))
opts.Add(BoolVariable('PSQL_ENABLE', 'Build PSQL modules when detected.', 
                      'off'))
opts.Add(BoolVariable('LINUX_MODULES', 
                      'Build linux modules when possible.', 'on'))

# Use PREFIX to generate defaults for the OTHER prefixes, so the OTHER
# prefixes will just be redundant if not specified.  Don't add the other
# options at all unless the corresponding build architecture is selected.

opts.Update(env)
BUILDS = Split(env['BUILDS'])
MACHS = Split(env['MACHS'])

if 'x86' in BUILDS:
    opts.Add('OTHER_X86',
             'Optional path to /include and /lib of other needed software',
             '$OTHER_PREFIX/x86')
    opts.Add('KERNELDIR', 'path to linux kernel source for build host, (use * for /usr/src/kernels/`uname -r`[-`uname -m`]:','*')

if 'arm' in BUILDS:
    opts.Add('KERNELDIR_viper', 'path to linux kernel source for Viper:',
             '/opt/arcom/src/linux-source-2.6.16.28-arcom1')
    opts.Add('KERNELDIR_titan', 'path to linux kernel source for Titan:',
             '/opt/arcom/src/linux-source-2.6.20.18-ael4')

if 'armbe' in BUILDS:
    opts.Add('KERNELDIR_vulcan', 'path to linux kernel source for Vulcan:',
             '/opt/arcom/src/linux-source-2.6.21.7-ael1')

opts.Update(env)
if env.has_key('PREFIX'):
    env['PREFIX'] = env.Dir(env['PREFIX']).get_abspath()
# Don't overwrite users config
# opts.Save('nidas.conf',env)

Help(opts.GenerateHelpText(env) + """
targets (use -c to clean targets)
(none) build linux modules for ARM, ARMBE, & X86, and ARM, ARMBE & X86 library and executables.
x86    build library and executable programs for X86.
arm  build linux driver modules, library and executable programs for Eurotech Viper and Titan.
armbe build linux driver modules, library and executable programs for Eurotech Vulcan.
lib    build all libraries
x86_install  build and install X86 library, headers and executables.
arm_install  build and install modules, library, headers and executables for Viper and Titan.
armbe_install  build and install modules, library, headers and executables for Vulcan.
install build and install all modules, libraries, headers and executables.
-c install  clean targets from $PREFIX
""")

##
##  TODO - Check out missing files from source control.
##
##  scons will, by default, fetch files from SCCS or RCS subdirecto-
##  ries without explicit configuration.  This takes some extra pro-
##  cessing time to search for the necessary source code  management
##  files  on disk.  You can avoid these extra searches and speed up
##  your build a little by disabling these searches as follows:
##
env.SourceCode('.', None)
##
##  Store all signatures in the '.sconsign.dblite'
##  file at the top-level SConstruct directory.
##
SConsignFile()

##
##  Define compiler flags and paths for all builds.
##
# scons man page:
# CFLAGS
#   General  options  that  are  passed  to the C compiler
#   (C only; not C++).
# CCFLAGS
#   General options that are passed to the C and C++  compilers.
# CXXFLAGS
#   General  options that are passed to the C++ compiler.  By
#   default, this includes the value  of  $CCFLAGS,  so  that
#   setting  $CCFLAGS affects both C and C++ compilation.  If
#   you want to add C++-specific flags, you must set or over-
#   ride the value of $CXXFLAGS.
#
# Warning: CXXFLAGS is before CCFLAGS in the compiler arguments:
# print 'CXXCOM=' + str(env['CXXCOM'])
# CXXCOM=$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES
#
# compiler string for building shareable code:
# print 'SHCXXCOM=' + str(env['SHCXXCOM'])
# SHCXXCOM=$SHCXX -o $TARGET -c $SHCXXFLAGS $SHCCFLAGS $_CCCOMCOM $SOURCES
#
# Because of the ordering, it isn't possible to add a CXX-only option
# at the end of the flags. Hence, don't put options in CCFLAGS that
# you may want to override for CXX.  For example:
# CCFLAGS='-Wall',  CXXFLAGS='-Wno-uninitialized', will result in
# -Wno-uninitialized -Wall, not the other way around.

# print 'CFLAGS=' + str(env['CFLAGS'])
# print 'CCFLAGS=' + str(env['CCFLAGS'])
# print 'SHCCFLAGS=' + str(env['SHCCFLAGS'])
# print 'CXXFLAGS=' + str(env['CXXFLAGS'])
# print 'SHCXXFLAGS=' + str(env['SHCXXFLAGS'])

env['CFLAGS'] = [ '-Wall','-O2' ]
env['CXXFLAGS'] = [ '-Wall','-O2' ]

env['CCFLAGS'] = [ ]

if env.has_key('XMLDEBUG') and env['XMLDEBUG']:
    env.AppendUnique(CPPDEFINES = ['XML_DEBUG'])

if env.has_key('DEBUG') and env['DEBUG']:
    env.AppendUnique(CPPDEFINES = ['DEBUG'])

if env.has_key('GDBDEBUG') and env['GDBDEBUG']:
    env.AppendUnique(CCFLAGS = ['-ggdb'])

env.Append(SHLIBMAJORVERSION = '1')
env.Append(SHLIBMINORVERSION = '0')
env.Append(USE_ARCHLIBDIR = 1)

infos = [env.SvnInfoBuilder("#/nidas/core/SvnInfo.h",["#/nidas"]),
    env.SvnInfoBuilder("#/nidas/linux/SvnInfo.h",["#/nidas/linux"])]

##
##  Install firmware
##
SConscript("firmware/anythingIO/SConscript",exports={'env':env})

##
##  Install a2d filters
##
SConscript("../filters/SConscript",exports={'env':env})

##
##  Create the env for building to the x86 processor...
##
if 'x86' in BUILDS:
    print "Setting up for x86 builds..."
    x86_env = env.Clone(tools = ['x86','symlink','sharedlibrary','kmake'],
        ARCH = 'x86',
        MACHS = ['x86'],
        PREFIX = env['PREFIX'] + '/x86',
        OTHER_PREFIX = env['OTHER_X86']
    )
    # print 'LIBDIR=' + x86_env["LIBDIR"]
    x86_env.AppendUnique(CCFLAGS = ["-g"])
    x86_env.AppendUnique(CXXFLAGS = ['-Wextra','-Weffc++'])
    exports = {'env':x86_env}

    SConscript('nidas/SConscript',
               variant_dir='build_x86',
               duplicate=0, exports=exports)
    # Alias('install','x86_install')
    Clean('x86','build_x86')      # Clean(target,files_or_dirs)

    # Testing targets, built and run only on x86
    SConscript("tests/goes_dcp/SConscript",exports=exports)
    SConscript("tests/iterators/SConscript",exports=exports)
    SConscript("tests/serial_sensor/SConscript",exports=exports)
    SConscript("tests/tlogger/SConscript",exports=exports)
    SConscript("tests/tiostream/SConscript",exports=exports)
    SConscript("tests/network/SConscript",exports=exports)
    SConscript("tests/sync_server_dump/SConscript",exports=exports)
    SConscript("tests/ck_xml/SConscript",exports=exports)
    SConscript("tests/UTime/SConscript",exports=exports)

    # initial attempt at using Package. Fails. To test, add 'packaging" tool above.
    if 0:
        rpm = x86_env.Package( NAME           = 'nidas',
             VERSION        = '1.0',
             PACKAGEVERSION = 1,
             PACKAGETYPE    = 'rpm',
             PACKAGING_INSTALL_LOCATION = x86_env['PREFIX'],
             LICENSE        = 'gpl',
             SUMMARY        = 'balalalalal',
             DESCRIPTION    = 'this should be really really long',
             X_RPM_GROUP    = 'Application/fu',
             SOURCE_URL     = 'http://www.eol.ucar.edu/nidas-1.0.tar.gz'

        )
        Alias('rpm',rpm)

##
##  Create the env for cross-building to the xScale ARM processor
##  (little-endian) on the arcom Viper and Titan.
##
if 'arm' in BUILDS:
    print "Setting up for arm build ..."
    if 'all' in MACHS:
        MACHS = ['viper','titan']

    arm_env = env.Clone(tools = ['armcross','symlink','sharedlibrary','kmake'],
        ARCH = 'arm',
        MACHS = MACHS,
        PREFIX = env['PREFIX'] + '/arm'
    )
    # g++ version 3.4.4 often gives false positives when
    # trying to detect uninitialized variables.
    if re.search("^3",arm_env['CXXVERSION']):
        arm_env.AppendUnique(CXXFLAGS = ['-Wnon-virtual-dtor','-Wno-uninitialized'])
    if not arm_env.has_key('DEBUG') or not arm_env['DEBUG']:
        arm_env.AppendUnique(CPPDEFINES = ['NDEBUG'])

    arm_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')
    SConscript('nidas/SConscript',
               variant_dir='build_arm',
               duplicate=0, exports={'env':arm_env})
    # Alias('install','arm_install')
    Clean('arm','build_arm')      # Clean(target,files_or_dirs)

##
##  Create the env for cross-building to the xScale ARM processor
##  (big-endian) on the arcom Vulcan.
##
if 'armbe' in BUILDS:
    print "Setting up for armbe build ..."
    if 'all' in MACHS:
        MACHS = ['vulcan']

    armbe_env = env.Clone(tools = ['armbecross','symlink','sharedlibrary','kmake'],
        ARCH = 'armbe',
        MACHS = MACHS,
        PREFIX = env['PREFIX'] + '/armbe',
    )
    armbe_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')

    if re.search("^3",armbe_env['CXXVERSION']):
        armbe_env.AppendUnique(CXXFLAGS = ['-Wnon-virtual-dtor','-Wno-uninitialized'])
    if not armbe_env.has_key('DEBUG') or not armbe_env['DEBUG']:
        armbe_env.AppendUnique(CPPDEFINES = ['NDEBUG'])

    SConscript('nidas/SConscript',
               variant_dir='build_armbe',
               duplicate=0, exports={'env':armbe_env})
    # Alias('install','armbe_install')
    Clean('armbe','build_armbe')      # Clean(target,files_or_dirs)


Default([BUILDS,infos])

# Install the schema where it can be referenced globally on the system.
Alias('install',
      Alias('xml_install',
            env.Install('$PREFIX/share/xml','#xml/nidas.xsd')))

Alias('install',
      Alias('scripts_install',
            env.Install('$PREFIX/x86/bin','#scripts/nidas_rpm_update.sh')))

dox = Command('#/../doc/doxygen/html/index.html',
              '#/../doc/doxygen_conf/nidas.doxy',
              'cd .. && doxygen $SOURCE')
Alias('dox', dox)
AlwaysBuild(dox)


