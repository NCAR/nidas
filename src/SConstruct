# -*- python -*-
##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

import os,sys

sys.path.insert(0,os.path.join(os.getcwd(),'sconslib'))

# import kmake

##
##  Create a new construction environment variable and
##  restrict it's build methods to be POSIX based only.
##
env = Environment(platform = 'posix', ENV = {'PATH' : os.environ['PATH']})

##
## command line options
##
opts = Options('nidas.conf')
opts.AddOptions(
    PathOption('PREFIX',
               'installation paths: $PREFIX/x86, $PREFIX/arm, $PREFIX/share',
               '/opt/nidas'))

# def kerneldir_validator(key,val,env):
# 	if val != '':
# 		return PathOption.PathExists(key,val,end)
# 	return

opts.Add('BUILDS',
         'Space-separated list of architectures to build and install.',
         'x86 arm')
opts.Add(BoolOption('DEBUG', 'Define DEBUG symbol.', 'off'))
opts.Add(BoolOption('XMLDEBUG', 'Enable the XML_DEBUG definition.', 'off'))
opts.Add(BoolOption('GDBDEBUG', 'Enable -ggdb flag.', 'off'))
opts.Add(BoolOption('PSQL_ENABLE', 'Build PSQL modules when detected.', 'off'))

# Use PREFIX to generate defaults for the OTHER prefixes, so the OTHER
# prefixes will just be redundant if not specified.  Don't add the other
# options at all unless the corresponding build architecture is selected.
# 
opts.Update(env)
BUILDS = Split(env['BUILDS'])
env['ARCHITECTURES'] = BUILDS

if 'x86' in BUILDS:
    opts.AddOptions(PathOption('OTHER_X86',
                               'path to xerces-c and xmlrpc++ for X86:',
                               '$PREFIX/x86'))
    opts.Add('KERNELDIR_X86', 'path to linux kernel source for X86:','')


if 'arm' in BUILDS:
    opts.AddOptions(PathOption('OTHER_ARM',
                               'path to xerces-c and xmlrpc++ for ARM:',
                               '$PREFIX/arm'))
    opts.Add('KERNELDIR_ARM', 'path to linux kernel source for ARM:','')

opts.Update(env)
opts.Save('nidas.conf',env)

Help(opts.GenerateHelpText(env) + """
targets
(none) build linux modules or ARM & X86, rtlinux modules for ARM, and ARM & X86 library and executables.
x86    build library and executable programs for X86.
arm    build linux and rtlinux driver modules, library and executable programs for ARM.
lib    build library for X86 and ARM.
x86_install  build and install X86 library and executables.
arm_install  build and install ARM modules, library and executables.
""")

##
##  TODO - Check out missing files from source control.
##
##  scons will, by default, fetch files from SCCS or RCS subdirecto-
##  ries without explicit configuration.  This takes some extra pro-
##  cessing time to search for the necessary source code  management
##  files  on disk.  You can avoid these extra searches and speed up
##  your build a little by disabling these searches as follows:
##
env.SourceCode('.', None)
##
##  Store all signatures in the '.sconsign.dblite'
##  file at the top-level SConstruct directory.
##
SConsignFile()

##
##  Define compiler flags and paths for all builds.
##
env['CCFLAGS'] = Split("""-Wall -O2""")
env['CXXFLAGS'] = Split("""-Wall -O2""")
env['CPPPATH'] = Split("#")

if env.has_key('XMLDEBUG') and env['XMLDEBUG']:
    env.AppendUnique(CPPDEFINES = ['XML_DEBUG'])

if env.has_key('DEBUG') and env['DEBUG']:
    env.AppendUnique(CPPDEFINES = ['DEBUG'])

if env.has_key('GDBDEBUG') and env['GDBDEBUG']:
    env.AppendUnique(CXXFLAGS = ['-ggdb'])

##
##  Create the env for cross-building to the xScale ARM processor...
##
if 'arm' in env['ARCHITECTURES']:
    print "Setting up for ARM builds..."
    arm_env = env.Copy(tools = ['armcross'], toolpath=['sconstools'],
	   ARCH = 'arm',
	   PREFIX = env['PREFIX'] + '/arm',
	   OTHER_PREFIX = env['OTHER_ARM'],
	   KERNELDIR=env['KERNELDIR_ARM'],
	   KMAKE='make ARCH=arm CROSS_COMPILE=arm-linux-' + ' KERNELDIR=' + env['KERNELDIR_ARM'])

    arm_env.Append(CPPDEFINES = 'NIDAS_EMBEDDED')
    SConscript('nidas/SConscript',
               build_dir='build_arm',
               duplicate=0, exports={'env':arm_env})
    Alias('install','arm_install')

##
##  Create the env for building to the x86 processor...
##
if 'x86' in env['ARCHITECTURES']:
    print "Setting up for x86 builds..."
    x86_env = env.Copy(tools = ['x86tools'], toolpath=['sconstools'],
	    ARCH = 'x86',
	    PREFIX = env['PREFIX'] + '/x86',
	    OTHER_PREFIX = env['OTHER_X86'],
	    KERNELDIR=env['KERNELDIR_X86'],
	    KMAKE='make KERNELDIR=' + env['KERNELDIR_X86'])

    x86_env.Replace(CCFLAGS = Split("-Wall -O2 -g"))
    x86_env.Replace(CXXFLAGS = Split("-Wall -O2 -g"))
    x86_env.AppendUnique(RPATH = [x86_env.subst('$PREFIX/lib')] )
    x86_env.AppendUnique(RPATH = [x86_env.subst('$OTHER_PREFIX/lib')] )
    SConscript('nidas/SConscript',
               build_dir='build_x86',
               duplicate=0, exports={'env':x86_env})
    Alias('install','x86_install')

    # Testing targets, built and run only on x86
    if 'test' in COMMAND_LINE_TARGETS:
        SConscript("../tests/tlogger/SConscript",exports={'env':env})


Default(env['ARCHITECTURES'])

# Install the schema where it can be referenced globally on the system.
Alias('install',
      Alias('xml_install',
            env.Install('$PREFIX/share/xml','#../xml/nidas.xsd')))

dox = Command('#/../doc/doxygen/html/index.html',
              '#/../doc/doxygen_conf/nidas.doxy',
              'cd .. && doxygen $SOURCE')
Alias('dox', dox)
AlwaysBuild(dox)

