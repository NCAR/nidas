# -*- python -*-
##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

import os, re
import eol_scons

# eol_scons.debug.SetDebug("true")
#
# Don't load tools that perform compiler or pkg-config checks
# until the cross tool is loaded, and PKG_CONFIG_PATH is set.
env = Environment(tools=['default','gitinfo'])

# Create the eol_scons global variables and the NIDAS variables from the same config file.
gopts = eol_scons.GlobalVariables('nidas.conf')
opts = Variables('nidas.conf')
opts.AddVariables(('PREFIX',
                   'installation path',
                   '/opt/nidas', None, eol_scons.PathToAbsolute))

opts.AddVariables(('OTHER_PREFIX',
                   'Optional prefix for other dependencies.',
                   None, None, eol_scons.PathToAbsolute))

# opts.Add('SVN_REVISION','svn version identifier', os.environ.get('SVN_REVISION') or '')

# May want to change this so that only single vales in BUILDS are allowed.
# Specifiying multiple BUILDS becomes problematic with the
# MACHS and ARCHLIBDIR parameters. Seems like overkill to
# make them arrays or dictionaries for each BUILD type.
# Specifying multiple BUILDS can result in this error:
#   "Multiple ways to build the same target were specified for ..."
# related to the MakeSymLink method in SharedLibrary3Install,
# even when just doing a clean.  Not sure how to fix it...
# So if you get that error, resort to single BUILDS.
opts.Add('BUILDS',
         'Space-separated list of architectures to build and install: host, arm, armbe, armel or armhf.',
         'host')

opts.Add('MACHS',
         'Space-separated list of machine names for the architecture (viper, vulcan, titan, rpi2 or all), for building and installing machine-specific code, such as kernel modules.',
         'all')

opts.Add(BoolVariable('DEBUG', 'Define DEBUG symbol.', 'off'))
opts.Add(BoolVariable('XMLDEBUG', 'Enable the XML_DEBUG definition.',
                      'off'))
opts.Add(BoolVariable('GDBDEBUG', 'Enable -ggdb flag.', 'off'))
opts.Add(BoolVariable('ENABLE_VALGRIND',
                      'Enable valgrind run-time hints.',
                      'off'))
opts.Add(BoolVariable('PSQL_ENABLE', 'Build PSQL modules when detected.', 
                      'off'))
opts.Add(BoolVariable('LINUX_MODULES', 
                      'Build linux modules when possible.', 'on'))
opts.Add('REPO_TAG', 
         'git tag of the source, in the form "vX.Y", when building outside of a git repository')
opts.Add('PKG_CONFIG_PATH', 
         'Path to pkg-config files, if you need other than the system default')

# Generally can let this default to the values set below.
# For x86_64 builds it defaults to 'lib64'. When building
# a Debian package for x86_64 (amd64), the Makefile that calls
# scons pre-sets it to lib/x86_64-linux-gnu to be similar with
# the arm libs and be more Debian-multiarch-like.
opts.Add('ARCHLIBDIR',
         'Where to install NIDAS libraries relative to $PREFIX')

opts.Add(BoolVariable('BUILD_RAF', 
                      'Build nidas/apps/auto_cal and nidas/apps/config.', 'on'))
opts.Update(env)

# Threads
env.MergeFlags('-pthread')

if 'PKG_CONFIG_PATH' in env:
    env.PrependENVPath('PKG_CONFIG_PATH', env['PKG_CONFIG_PATH'])

BUILDS = Split(env['BUILDS'])
MACHS = Split(env['MACHS'])

if 'host' in BUILDS or 'x86' in BUILDS:
    opts.Add('KERNELDIR', 'path to linux kernel source for build host, (use * for /usr/src/kernels/`uname -r`[-`uname -m`]:','*')

if 'arm' in BUILDS:
    opts.Add('KERNELDIR_viper_arm', 'path to linux kernel source for Viper:',
             '/opt/arcom/src/linux-source-2.6.35.9-ael1-viper')
    opts.Add('KERNELDIR_titan_arm', 'path to linux kernel source for Titan:',
             '/opt/arcom/src/linux-source-2.6.35.9-ael1-titan')

if 'armbe' in BUILDS:
    opts.Add('KERNELDIR_vulcan_armbe', 'path to linux kernel source for Vulcan:',
             '/opt/arcom/src/linux-source-2.6.21.7-ael2-vulcan')

if 'armel' in BUILDS:
    opts.Add('KERNELDIR_viper_armel', 'kernel headers for Viper/armel. See Debian package linux-headers-3.16.0-viper2:armel',
             '/usr/src/linux-headers-3.16.0-viper2')
    opts.Add('KERNELDIR_titan_armel', 'kernel headers for Titan/armel. See Debian package linux-headers-3.16.0-titan2:armel',
             '/usr/src/linux-headers-3.16.0-titan2')

# This isn't quite ready for cross building modules for armhf, RPi2.
# linux-headers contains an executable scripts/genksyms/genksyms that is used
# in building modules. The package we have on our Debian chroots has a genksyms
# that is an armhf binary, meant for building on a RPi. Until that is sorted out,
# don't set KERNELDIR_rpi2_armhf.

if 'armhf' in BUILDS:
    opts.Add('KERNELDIR_rpi2_armhf', 'kernel headers for Raspberry Pi2. See raspberrypi-kernel-headers package ','/usr/src/linux-headers-4.4.11-v7n')

opts.Update(env)

##
##  Define compiler flags and paths for all builds.
##
# scons man page:
# CFLAGS
#   General  options  that  are  passed  to the C compiler
#   (C only; not C++).
# CCFLAGS
#   General options that are passed to the C and C++  compilers.
# CXXFLAGS
#   General  options that are passed to the C++ compiler.  By
#   default, this includes the value  of  $CCFLAGS,  so  that
#   setting  $CCFLAGS affects both C and C++ compilation.  If
#   you want to add C++-specific flags, you must set or over-
#   ride the value of $CXXFLAGS.
#
# Warning: CXXFLAGS is before CCFLAGS in the compiler arguments:
# print('CXXCOM=' + str(env['CXXCOM']))
# CXXCOM=$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES
#
# compiler string for building shareable code:
# print('SHCXXCOM=' + str(env['SHCXXCOM']))
# SHCXXCOM=$SHCXX -o $TARGET -c $SHCXXFLAGS $SHCCFLAGS $_CCCOMCOM $SOURCES
#
# Because of the ordering, it isn't possible to add a CXX-only option
# at the end of the flags. Hence, don't put options in CCFLAGS that
# you may want to override for CXX.  For example:
# CCFLAGS='-Wall',  CXXFLAGS='-Wno-uninitialized', will result in
# -Wno-uninitialized -Wall, not the other way around.

# print('CFLAGS=' + str(env['CFLAGS']))
# print('CCFLAGS=' + str(env['CCFLAGS']))
# print('SHCCFLAGS=' + str(env['SHCCFLAGS']))
# print('CXXFLAGS=' + str(env['CXXFLAGS']))
# print('SHCXXFLAGS=' + str(env['SHCXXFLAGS']))

env['CFLAGS'] = [ '-Wall','-O2' ]
env['CXXFLAGS'] = [ '-Wall','-O2' ]

env['CCFLAGS'] = [ ]

if 'XMLDEBUG' in env and env['XMLDEBUG']:
    env.AppendUnique(CPPDEFINES = ['XML_DEBUG'])

if 'DEBUG' in env and env['DEBUG']:
    env.AppendUnique(CPPDEFINES = ['DEBUG'])

if 'GDBDEBUG' in env and env['GDBDEBUG']:
    env.AppendUnique(CCFLAGS = ['-ggdb'])

##
##  Install firmware
##
SConscript("firmware/anythingIO/SConscript",exports={'env':env})

##
##  Install a2d filters
##
SConscript("../filters/SConscript",exports={'env':env})

# Check for supported -fstack-protector options in compiler
def CheckStackProtectorOptions(env):
    def add_stack_option(env, opt):
        test_env = env.Clone()
        test_env.AppendUnique(CCFLAGS = [opt])
        conf = Configure(test_env)
        print('Checking gcc option ' + opt + '...')
        ok = conf.CheckCC()
        conf.Finish()
        if ok:
            env.AppendUnique(CCFLAGS = [opt])
        return ok
    for opt in ['-fstack-protector-strong', '-fstack-protector']:
        if add_stack_option(env, opt):
            break
    add_stack_option(env, '-fstack-check')

##
##  Create the env for building to the host processor...
##
if 'host' in BUILDS or 'x86' in BUILDS:
    print("Setting up for host builds...")
    host_env = env.Clone(tools = ['symlink','sharedlibrary', 'xmlrpc'],
        ARCH = '', MACHS=[''])

    host_env.AppendUnique(CCFLAGS = ['-g', '-fpic',
            '-Wformat', '-Werror=format-security',
            '-D_FORTIFY_SOURCE=2'])
    host_env.AppendUnique(CXXFLAGS = ['-Wextra','-Weffc++'])
    CheckStackProtectorOptions(host_env)

# hardening option "-pie" in LINKFLAGS results in this error:
# /usr/bin/ld: /opt/local/lib/libraf++.a(PMSspex.o): relocation R_X86_64_32
# against `.rodata.str1.1' can not be used when making a shared object; recompile with -fPIC

    host_env.AppendUnique(LINKFLAGS = ['-Wl,-z,relro', '-Wl,-z,now'])

    exports = {'env':host_env}

    SConscript('nidas/SConscript',
               variant_dir='build',
               duplicate=0, exports=exports)

    Alias('x86','build')
    Alias('host','build')
    Clean('build','build')

    # Testing targets, built and run only on host
    SConscript("tests/iterators/SConscript",exports=exports)
    SConscript("tests/serial_sensor/SConscript",exports=exports)
    SConscript("tests/tlogger/SConscript",exports=exports)
    SConscript("tests/core/SConscript",exports=exports)
    SConscript("tests/data_dump/SConscript",exports=exports)
    SConscript("tests/tiostream/SConscript",exports=exports)
    SConscript("tests/network/SConscript",exports=exports)
    SConscript("tests/sync_server_dump/SConscript",exports=exports)
    SConscript("tests/ck_xml/SConscript",exports=exports)
    SConscript("tests/ck_calfile/SConscript",exports=exports)
    SConscript("tests/UTime/SConscript",exports=exports)
    SConscript("tests/sonic/SConscript",exports=exports)
    SConscript("tests/prep/SConscript",exports=exports)
    SConscript("tests/dausensor/SConscript",exports=exports)

##
##  Create the env for cross-building to the xScale ARM processor
##  (little-endian) on the arcom Viper and Titan.
##
if 'arm' in BUILDS:
    print("Setting up for arm build ...")

    # supported machine types for arm
    amachs = { 'all': ['viper','titan'], 'viper':['viper'], 'titan': ['titan']}
    # build list of machine types to build from MACHS="x y z" command line
    machs = []
    for m in MACHS:
        if m in amachs:
            machs.extend(amachs[m])
    machs = list(set(machs))    # unique-ify

    arm_env = env.Clone(tools = ['armcross','symlink','sharedlibrary', 'xmlrpc'],
        ARCH = 'arm', ARCHLIBDIR='lib', MACHS=machs,
        PREFIX=env['PREFIX'] + '/arm')

    arm_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')
    CheckStackProtectorOptions(arm_env)
    # g++ version 3.4.4 often gives false positives when
    # trying to detect uninitialized variables.
    if re.search("^3",arm_env['CXXVERSION']):
        arm_env.AppendUnique(CXXFLAGS = ['-Wnon-virtual-dtor','-Wno-uninitialized'])
    if 'DEBUG' not in arm_env or not arm_env['DEBUG']:
        arm_env.AppendUnique(CPPDEFINES = ['NDEBUG'])


    SConscript('nidas/SConscript',
               variant_dir='build_arm',
               duplicate=0, exports={'env':arm_env})
    Alias('arm','build_arm')
    Clean('build_arm','build_arm')

##
##  Create the env for cross-building to the xScale ARM processor
##  (big-endian) on the arcom Vulcan.
##
if 'armbe' in BUILDS:
    print("Setting up for armbe build ...")

    # supported machine types for armbe
    amachs = { 'all': ['vulcan'], 'vulcan':['vulcan']}
    # build list of machine types to build from MACHS="x y z" command line
    machs = []
    for m in MACHS:
        if m in amachs:
            machs.extend(amachs[m])
    machs = list(set(machs))    # unique-ify

    armbe_env = env.Clone(tools = ['armbecross','symlink','sharedlibrary', 'xmlrpc'],
        ARCH = 'armbe', ARCHLIBDIR='lib', MACHS=machs,
        PREFIX=env['PREFIX'] + '/armbe')

    armbe_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')
    CheckStackProtectorOptions(armbe_env)

    if re.search("^3",armbe_env['CXXVERSION']):
        armbe_env.AppendUnique(CXXFLAGS = ['-Wnon-virtual-dtor','-Wno-uninitialized'])
    if 'DEBUG' not in armbe_env or not armbe_env['DEBUG']:
        armbe_env.AppendUnique(CPPDEFINES = ['NDEBUG'])

    SConscript('nidas/SConscript',
               variant_dir='build_armbe',
               duplicate=0, exports={'env':armbe_env})
    Alias('armbe','build_armbe')
    Clean('build_armbe','build_armbe')

if 'armel' in BUILDS:
    print("Setting up for armel build ...")

    # supported machine types for armel.
    amachs = { 'all': ['titan', 'viper'], 'viper':['viper'], 'titan': ['titan']}
    # build list of machine types to build from MACHS="x y z" command line
    machs = []
    for m in MACHS:
        if m in amachs:
            machs.extend(amachs[m])
    machs = list(set(machs))    # unique-ify

    armel_env = env.Clone(tools = ['armelcross','symlink','sharedlibrary', 'xmlrpc'],
        ARCH = 'armel', MACHS=machs)

    if 'ARCHLIBDIR' not in armel_env:
        armel_env['ARCHLIBDIR'] = 'lib/arm-linux-gnueabi'

    CheckStackProtectorOptions(armel_env)
    armel_env.AppendUnique(CCFLAGS = ['-g', '-fpie',
            '-Wformat', '-Werror=format-security',
            '-D_FORTIFY_SOURCE=2'])
    armel_env.AppendUnique(CXXFLAGS = ['-Wextra','-Weffc++'])
    armel_env.AppendUnique(LINKFLAGS = ['-pie', '-Wl,-z,relro', '-Wl,-z,now'])

    if 'DEBUG' not in armel_env or not armel_env['DEBUG']:
        armel_env.AppendUnique(CPPDEFINES = ['NDEBUG'])

    armel_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')

    SConscript('nidas/SConscript',
               variant_dir='build_armel',
               duplicate=0, exports={'env':armel_env})
    Alias('armel','build_armel')
    Clean('build_armel','build_armel')

if 'armhf' in BUILDS:
    print("Setting up for armhf build ...")

    # supported machine types for armhf.
    amachs = { 'all': ['rpi2'], 'rpi2': ['rpi2'], }
    # build list of machine types to build from MACHS="x y z" command line
    machs = []
    for m in MACHS:
        if m in amachs:
            machs.extend(amachs[m])
    machs = list(set(machs))    # unique-ify

    armhf_env = env.Clone(tools = ['armhfcross','symlink','sharedlibrary', 'xmlrpc'],
        ARCH = 'armhf', MACHS=machs)

    if 'ARCHLIBDIR' not in armhf_env:
        armhf_env['ARCHLIBDIR'] = 'lib/arm-linux-gnueabihf'
    CheckStackProtectorOptions(armhf_env)
    armhf_env.AppendUnique(CCFLAGS = ['-g', '-fpie',
            '-Wformat', '-Werror=format-security',
            '-D_FORTIFY_SOURCE=2'])
    armhf_env.AppendUnique(CXXFLAGS = ['-Wextra','-Weffc++'])
    armhf_env.AppendUnique(LINKFLAGS = ['-pie', '-Wl,-z,relro', '-Wl,-z,now'])

    if 'DEBUG' not in armhf_env or not armhf_env['DEBUG']:
        armhf_env.AppendUnique(CPPDEFINES = ['NDEBUG'])

# armhf_env.AppendUnique(CPPDEFINES = 'NIDAS_EMBEDDED')

    SConscript('nidas/SConscript',
               variant_dir='build_armhf',
               duplicate=0, exports={'env':armhf_env})
    Alias('armhf','build_armhf')
    Clean('build_armhf','build_armhf')


Default([BUILDS])

# Install the schema where it can be referenced globally on the system.
Alias('install',
      Alias('xml_install',
            env.Install('$PREFIX/share/xml','#xml/nidas.xsd')))

dox = env.Command('#/../doc/doxygen',
              '#/../doc/doxygen_conf/nidas.doxy',
              'cd .. && rm -rf doc/doxygen && ( cat $SOURCE; echo PROJECT_NUMBER=$REPO_TAG ) | doxygen -')
Alias('dox', dox)
AlwaysBuild(dox)

# Use InstallAs to $PREFIX/doxygen. Otherwise $PREFIX becomes
# a target, and the other install targets this rule to create $PREFIX
Alias('doxinstall', env.InstallAs('$PREFIX/doxygen','#/../doc/doxygen'))

opts.Update(env)
gopts.Update(env)
Help(opts.GenerateHelpText(env) + gopts.GenerateHelpText(env) + """
targets (use -c to clean targets)
(none) build libraries, executables and kernel modules for ARM, ARMBE, & native systems.
host    build libraries, executable programs and modules for host system.
arm    build libraries, executables and kernel modules for Eurotech Viper and Titan, running (obsolete) Arcom Embedded Linux
armbe  build libraries, executables and kernel modules for Eurotech Vulcan, running Arcom Embedded Linux
armel  build libraries, executables and kernel modules for Eurotech Viper and Titan, Debian 8
armhf  build libraries, executables and kernel modules for ARMv6/7 systems, such as R Pi2, running Raspian
install build and install all modules, libraries, headers and executables.
-c install  clean targets from $PREFIX
""")

