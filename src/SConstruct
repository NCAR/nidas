# -*- python -*-
##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

import textwrap
import SCons
from SCons.Script import Environment, SConscript, BoolVariable, Variables
from SCons.Script import COMMAND_LINE_TARGETS, ARGUMENTS, AddOption
from SCons.Script import SConsignFile
import eol_scons
import subprocess as sp
import platform

# Here are the supported build targets, expressed in the form arch-machine,
# which loosely follows the GNU GCC machine configuration name of
# arch-company-system, where system is implied to be linux.  Only one of these
# targets can be built in a single scons build.  This dictionary of arch-mach
# names maps to a tuple of (arch, mach).

targets = {
    'arm-viper': ('arm', 'viper'),
    'arm-titan': ('arm', 'titan'),
    'armbe-vulcan': ('armbe', 'vulcan'),
    'armel-titan': ('armel', 'titan'),
    'armel-viper': ('armel', 'viper'),
    'armhf-rpi2': ('armhf', 'rpi2'),
    'armhf-rpi3': ('armhf', 'rpi3'), # not actually different, but accept it
    'host-host': ('host', 'host')
}

eol_scons.EnableInstallAlias(False)

# eol_scons.debug.SetDebug("true")
#
# Don't load tools that perform compiler or pkg-config checks until the cross
# tool is loaded, PKG_CONFIG_PATH is set, and the custom config filename
# nidas.conf can be set.
env = Environment(tools=['default'], toolpath=['#/tools'])

# This passes all settings from the calling environment.  This was a quick fix
# for supercomputer builds (casper) which use modules to setup the environment,
# to pull in specific sets and versions of tools and libraries. It is left here
# disabled as a placeholder until it's needed again and a less heavy-handed
# approach can be found.
if False:
    env.PassEnv('')

# Create the eol_scons global variables and the NIDAS variables from the
# same config file.
opts = eol_scons.GlobalVariables('nidas.conf')
opts: Variables
opts.AddVariables(('PREFIX',
                   'installation path',
                   '/opt/nidas', None, eol_scons.PathToAbsolute))

# Only one target architecture can be built in a single scons run, and each
# target uses a different variant build dir.
opts.Add('BUILD',
"""
 Target architecture and machine to build and install.  The default, 'host',
 is a native build, everything else requires a cross-compiler.  BUILD can be a
 fully qualified target name, or it can be just the machine name or
 architecture.  If there is more than one match, the first found is used.  If
 BUILD is not set, then it can be implied by using the target name as a
 command-line target, as in 'scons armhf'.  For backwards compatibility,
 BUILDS and MACHS are checked for a matching target if BUILD is not set and no
 command-line targets match.  Here are the supported targets, in the form
 architecture-machine:%s
""" % ("\n" + ",".join(targets.keys())))

opts.Add(BoolVariable('DEBUG', 'Define DEBUG symbol.', 'off'))
opts.Add(BoolVariable('GDBDEBUG', 'Enable -ggdb flag.', 'off'))
opts.Add(BoolVariable('ENABLE_VALGRIND',
                      'Enable valgrind run-time hints.',
                      'off'))
opts.Add(BoolVariable('LINUX_MODULES', 
                      'Build linux modules when possible.', 'on'))
opts.Add('REPO_TAG',
"""
 git tag of the source, in the form "vX.Y", when building outside of a git
 repository
""")
opts.Add('PKG_CONFIG_PATH',
"""
 Path to pkg-config files, if you need other than the system default
""")

# Generally can let this default to the values set below.
# For x86_64 builds it defaults to 'lib64'. When building
# a Debian package for x86_64 (amd64), the Makefile that calls
# scons pre-sets it to lib/x86_64-linux-gnu to be similar with
# the arm libs and be more Debian-multiarch-like.
opts.Add('ARCHLIBDIR', """
 Where to install NIDAS libraries relative to $PREFIX.
""", None)

opts.Update(env)


def lookup_target(target):
    """
    Look for target name among supported targets, where the name has to match
    either arch or mach or the whole target name.  Return the full target
    name, the key into the dictionary of supported targets.
    """
    for k, v in targets.items():
        if k == target or v[0] == target or v[1] == target:
            return k
    return None


def check_target(env):
    """
    Check that the BUILD setting or a command-line target matches a supported
    target, handling backwards compatibility with BUILDS and MACHS, and then
    derive the MACH and ARCH settings from that.
    """
    # command-line targets take precedence, so look for that first.
    build = None
    for target in COMMAND_LINE_TARGETS:
        build = lookup_target(target)
        if build:
            break
    # if no command-line targets matched, look for a variable setting
    if not build:
        for v in ['BUILD', 'BUILDS', 'MACHS']:
            target = ARGUMENTS.get(v)
            build = lookup_target(target)
            if build:
                break
            if target:
                msg = f"{v}={target} does not match a supported target"
                raise SCons.Errors.StopError(msg)
    # no command-line target and no variable setting, so default to host
    if not build:
        build = 'host-host'
        target = build

    # build is now the name of one of the supported targets, target is the
    # name by which it was matched from the command-line or in a variable.
    # target will become an alias.  anything else on the command-line which
    # was an extra target or did not match will cause an error from scons
    # about unknown target, as expected.

    (arch, mach) = targets.get(build)
    env['ARCH'] = arch
    env['MACH'] = mach
    env['NIDAS_BUILD'] = build
    return target


build = check_target(env)


def get_variant_dir(env):
    """
    Derive the variant build dir for the arch and mach of the given
    environment.
    """
    arch = env.get('ARCH')
    mach = env.get('MACH')
    vdir = "build"
    if arch and arch != 'host':
        vdir += "_" + arch
    if mach and mach != 'host':
        vdir += "_" + mach
    return vdir


# as soon as we know the target, we can set the path to the variant build dir
env['VARIANT_DIR'] = '#/' + get_variant_dir(env)

# it might be ok to use the same database for different variant builds, since
# all the paths are different, and presumably that way the source signatures
# can be shared.  however, if that ever seems to cause problems, this puts the
# .sconsign database in the variant dir also.
if False:
    SConsignFile(get_variant_dir(env) + "/.sconsign")

ARCH = env['ARCH']
MACH = env['MACH']

env.PrintProgress(f"Setting up for {ARCH} build, {MACH} target machine...")

if 'PKG_CONFIG_PATH' in env:
    env.PrependENVPath('PKG_CONFIG_PATH', env['PKG_CONFIG_PATH'])

# NIDAS uses PREFIX as the root install prefix, but since it's a
# Variable that SCons sets, that means it should only have one value
# for the entire build rather than be modified for each variant build.
# So the arch-specific prefix is stored in the ARCHPREFIX variable,
# and it defaults to just PREFIX.  This way there can be an
# arch-specific install location which gets built up from the main
# PREFIX.
#
# Targets which should be installed in arch-specific locations should
# use ARCHPREFIX, while targets which are not arch-specific can go
# under PREFIX.  For native host builds, they will be the same.
env['ARCHPREFIX'] = '$PREFIX'

# env['CXX'] = 'clang++'
env['CFLAGS'] = ['-Wall','-O2']
env['CXXFLAGS'] = ['-Wall', '-O2']
if env['CXX'] == 'clang++':
    # Someday it might be nice to refactor the remaining overloaded virtual
    # functions, but for now they're working and haven't seemed to bite us yet.
    env.AppendUnique(CXXFLAGS=['-Wno-overloaded-virtual'])
    # Ignore inconsistent overrides to add them piecemeal.
    env.AppendUnique(CXXFLAGS=['-Wno-inconsistent-missing-override'])
    # env.AppendUnique(CXXFLAGS=['-stdlib=libstdc++'])
    # env.AppendUnique(LDFLAGS=['-rtlib=libgcc'])

if env.get('DEBUG'):
    env.AppendUnique(CPPDEFINES=['DEBUG'])

env['CCFLAGS'] = []
if env.get('GDBDEBUG'):
    env.AppendUnique(CCFLAGS=['-ggdb'])

# Load nidasconfig tool before any Configure contexts are created in this tree
# or external tools, so the settings can be stored in the variant dirs.
env.Tool('nidasconfig')
env.Tool(f'nidas_{ARCH}')
env.Require(['symlink', 'sharedlibrary', 'stackprotector'])

# Threads
env.MergeFlags('-pthread')

if not env.get('DEBUG'):
    env.AppendUnique(CPPDEFINES = ['NDEBUG'])

# Now start loading SConscript files...

##
##  Install firmware
##
SConscript("firmware/anythingIO/SConscript", exports={'env': env})

##
##  Install a2d filters
##
SConscript("../filters/SConscript", exports={'env': env})


SConscript('nidas/SConscript', variant_dir=env['VARIANT_DIR'],
           duplicate=1, exports={'env': env})

# need at least one default target, else scons will build everything.  this
# makes the default everything built into the variant dir.  the alias allows
# scons to a build the target when specified as a command-line target.
env.Default(env.Alias(build, env['VARIANT_DIR']))

if ARCH == 'host' and env.File("tests/SConscript").exists():
    # Testing targets, built and run only on host. When building packages,
    # it is not even in the source tree.
    SConscript("tests/SConscript", exports={'env': env})

# Install the schema where it can be referenced globally on the system.
env.Alias('install', env.Install('$PREFIX/share/xml','#xml/nidas.xsd'))

dox = env.Command('#/../doc/doxygen',
              '#/../doc/doxygen_conf/nidas.doxy',
              'cd .. && rm -rf doc/doxygen && ( cat $SOURCE; echo PROJECT_NUMBER=$REPO_TAG ) | doxygen -')
env.Alias('dox', dox)
env.AlwaysBuild(dox)

# Use InstallAs to $PREFIX/doxygen.  Do not install docs unless explicitly
# requested, so that --install-sandbox does not automatically install the docs
# with the other install targets.
if 'doxinstall' in COMMAND_LINE_TARGETS:
    env.Alias('doxinstall',
              env.InstallAs('$PREFIX/doxygen','#/../doc/doxygen'))


# Override the SCons variable help formatter before calling SetHelp(), since
# that actually generates all the text.
def BriefVariableHelpText(env, key, help, default, actual, aliases=None) -> str:
    briefs = ['PREFIX', 'BUILD', 'LINUX_MODULES',
              'PKG_CONFIG_PATH', 'BUILD_ARINC']
    if key not in briefs:
        return ''
    brief = help or ''
    (first, dot, _) = brief.partition('. ')
    brief = (first + '.') if dot else first
    brief = textwrap.shorten(brief, width=60, placeholder='...')
    brief = f'  {brief}\n' if brief else brief
    text = "%s [%s]\n%s" % (key, actual, brief)
    return text

AddOption("--help-all", dest="helpall", action="store_true")
if not env.GetOption("helpall"):
    opts.FormatVariableHelpText = BriefVariableHelpText

# Use the eol_scons SetHelp() method to generate all the help text,
# including the directory of aliases, but then append a custom summary of
# nidas targets.
env.SetHelp()
nidas_help = """
Main targets:

<target> or BUILD=<target>
  Build libraries, executables and kernel modules for target system.  See BUILD.
install
  Build and install all modules, libraries, headers and executables.
-c install
  Clean targets from $PREFIX.
-c .
  Clean builds in source tree for the selected target.

Use scons -h --help-all to see all variables with full help info.
"""
env.AddHelp(nidas_help)
