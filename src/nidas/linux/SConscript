# -*- python -*-
## 2006, Copyright University Corporation for Atmospheric Research

import os
from SCons.Script import Environment, Import

env: Environment

##
##  Import the build environment.
##
Import('env')

headers = env.Split("""
    a2d.h
    isa_bus.h
    irigclock.h
    klog.h
    mesa.h
    ncar_a2d.h
    short_filters.h
    types.h
    util.h
""")

subdirs = env.Split("""
    arinc
    diamond
    filters
    irig
    lams
    mesa
    ncar_a2d
    serial
    viper
    usbtwod
    util
""")


# Create a Revision header specifically for the kernel modules to include.
# Like for nidas/Revision.h, this is not built into the variant dir.
info = env.GitInfo("#/nidas/linux/Revision.h", "#/nidas/linux")
env.Alias('install', env.Install('$ARCHPREFIX/include/nidas/linux', info))


symvers = {
    'revinfo': info[0],
    'util': env.File('util/Module.symvers'),
    'filters': env.File('filters/Module.symvers'),
    'irig': env.File('irig/Module.symvers')
}


def SymbolModules(env: Environment, *keys):
    "Translate a list of subdirs into the corresponding symbol files."
    return [symvers[k] for k in keys]


def NidasKernelModule(env, modules, sources, headers=None):
    """
    Pseudo-builder for all NIDAS kernel modules.  Return the module targets if
    build enabled, else None.

    headers are added to sources and also installed into the nidas/linux
    include directory.

    Makefile is added to sources if not present.  The Makefile must be listed
    in the source dependencies so that it is copied/linked to the variant_dir.
    The Kmake builder runs the make command in variant_dir.

    Also, the SConscript command that invokes this SConscript file should set
    duplicate=1, so that all the linux module source files, including the
    Makefile, are copied to the variant_dir.  so that make can find them and
    do its work outside of the source tree.

    All modules must be built by the same kmake builder so SCons will setup
    all the variant_dir copies/links before running make.  Otherwise make
    fails because not all the dependencies exist yet.
    """
    targets = None
    thisdir = env.Dir('.').srcnode().abspath
    env.LogDebug("NidasKernelModule setup in %s..." % (thisdir))
    subdir = os.path.basename(thisdir)
    installs = []

    # If LINUX_MODULES is undefined or True, then the user wants to build
    # the linux modules.
    if env.get("LINUX_MODULES", True) and env.get("KERNELDIR"):

        if 'Makefile' not in sources:
            sources += ['Makefile']

        # Make sure all the source files exist, otherwise the module is
        # presumed to be a git submodule which has not been populated and
        # cannot be built.
        exists = True
        for source in [env.File(s).srcnode().abspath for s in sources]:
            if not source.startswith(thisdir):
                continue
            if os.path.exists(source):
                env.LogDebug(f"{subdir} kernel module source "
                             f"file found: {source}")
            else:
                print(f"{subdir} kernel module will not be built, "
                      f"source file missing: {source}")
                exists = False
                break

        if exists:
            targets = env.Kmake(modules, sources + (headers or []))
            installs += env.Install('$LINUX_MODULES_INST_PATH', modules)

    # Not sure if headers are meant to be installed even when the module
    # is not being built...
    if headers:
        installs += env.Install('$LINUX_MODULES_INC/' + subdir, headers)
    if installs:
        env.Alias('install', installs)

    return targets


def InstallModuleConf(env: Environment, modconf):
    "Pseudo-builder to install modprobe.d conf files."
    if env.get("LINUX_MODULES", True):
        conf = env.Install('${INSTALL_ROOT}/etc/modprobe.d', modconf)
        env.Alias('install.root', conf)


def nidas_kernel_modules(env: Environment):
    "Tool to add the ModuleSymbols method to an Environment."
    env.AddMethod(SymbolModules)
    env.AddMethod(NidasKernelModule)
    env.AddMethod(InstallModuleConf)

#
# Invoke SConscripts in subdirs to create linux modules.
#

# Set KERNELDIR according to ARCH and MACH.
env.Tool('kerneldir')

# kernel module builds need absolute include paths because they are run in
# a different working directory
incpaths = set([env.Dir(p).abspath for p in env['CPPPATH']])
kflags = ' '.join(['-I%s' % (p) for p in incpaths])
env['KCFLAGS'] = kflags

# module installation path must be unique for each machine type.  For native
# builds, modpath is simply $PREFIX/modules.
modpath = '$ARCHPREFIX/modules'
mach = env.get('MACH')
modpath += '' if not mach or mach == 'host' else ('/' + mach)
env['LINUX_MODULES_INST_PATH'] = modpath
env['LINUX_MODULES_INC'] = '$ARCHPREFIX/include/nidas/linux'

env.Require(['kmake', nidas_kernel_modules])

# The environment does not need to be cloned for each module, since the
# construction variables are all the same for each module.  They also do not
# need to be variants with duplicate=1, because that is done once at the top
# for the entire variant target.

for subdir in subdirs:
    env.SConscript('%s/SConscript' % subdir, exports=[{'env': env}])

env.Alias('install', env.Install('$LINUX_MODULES_INC', headers))

env.InstallModuleConf('nidas.conf')
