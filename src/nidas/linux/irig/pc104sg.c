/* pc104sg.c

driver for Brandywine's PC104-SG IRIG card
(adapted from Gordon Maclean's RT-Linux driver for the card)

Copyright 2007 UCAR, NCAR, All Rights Reserved

Revisions:

$LastChangedRevision: 3648 $
$LastChangedDate: 2007-01-31 11:23:38 -0700 (Wed, 31 Jan 2007) $
$LastChangedBy: cjw $
$HeadURL: http://svn.atd.ucar.edu/svn/nids/trunk/src/nidas/rtlinux/pc104sg.c $
*/

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/version.h>

#include <linux/fs.h>	/* has to be before <linux/cdev.h>! GRRR! */
#include <linux/cdev.h>
#include <linux/poll.h>
#include <linux/delay.h>
#include <linux/ioport.h>
#include <linux/syscalls.h>
#include <linux/time.h>
#include <linux/timer.h>
#include <linux/unistd.h>
#include <linux/wait.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>

#include <asm/atomic.h>
#include <asm/io.h>
#include <asm/semaphore.h>
#include <asm/uaccess.h>

#include <nidas/linux/irigclock.h>
#include <nidas/linux/isa_bus.h>
#include <nidas/linux/klog.h>

#include "pc104sg.h"

MODULE_AUTHOR("Chris Burghart <burghart@ucar.edu>");
MODULE_DESCRIPTION("PC104-SG IRIG Card Driver");
MODULE_LICENSE("GPL");

//#define DEBUG

/* desired IRIG interrupt rate, in Hz */
static const int INTERRUPT_RATE = 100;

/* desired IRIG clock frequency for A/D, in Hz */
static unsigned int A2DClockFreq = 10000;

/* module parameters (can be passed in via command line) */
static unsigned int Irq = 10;

static int IoPort = 0x2a0;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
module_param(Irq, int, 0);
module_param(IoPort, int, 0);
module_param(A2DClockFreq, int, 0);
#else
MODULE_PARM(Irq, "1i");
MODULE_PARM_DESC(Irq, "IRQ number");
MODULE_PARM(IoPort, "1i");
MODULE_PARM_DESC(IoPort, "I/O base address");
MODULE_PARM(A2DClockFreq, "1i");
MODULE_PARM_DESC(A2DClockFreq, "clock rate for A/D signal");
#endif

/* 
 * The IRQ_DEVID is arbitrary, but should be unique among devices that
 * might share an IRQ.
 */
static const unsigned long IRQ_DEVID = 0xf0f0f0f0;

/* Actual physical address of this card. Set in init_module */
static unsigned int ISA_Address;

/* 
 * The three possible interrupts generated by this card are enabled with
 * bits 5,6,7 of the status port:
 *
 *    5 = heartbeat
 *    6 = match
 *    7 = external-time-tag
 *
 * Writing a 0 to bits 0-4 causes other things, like board reset,
 * so we set those bits to 1 here in the interrupt mask.
 */
static unsigned char IntMask = 0x1f;

/**
 * Symbols with external scope, referenced via GET_MSEC_CLOCK
 * macro by other modules.
 */
unsigned long volatile MsecClock[2] = { 0, 0 };
unsigned char volatile ReadClock = 0;

EXPORT_SYMBOL(MsecClock);
EXPORT_SYMBOL(ReadClock);

/**
 * local clock variables.
 */
static unsigned char volatile WriteClock = 1;

/**
 * The millisecond clock counter.
 */
static unsigned long volatile MsecClockTicker = 0;

/** number of milliseconds per interrupt */
#define MSEC_PER_INTERRUPT (MSECS_PER_SEC / INTERRUPT_RATE)

/*
 * We perform a callback check after every INTERRUPTS_PER_CALLBACK_CHECK
 * interrupts.
 */
static const int INTERRUPTS_PER_CALLBACK_CHECK = 1;
#define MSEC_PER_CALLBACK_CHECK (MSEC_PER_INTERRUPT *		\
				 INTERRUPTS_PER_CALLBACK_CHECK)

/*
 * Allow for counting up to 10 seconds, so that we can do 0.1hz callbacks.
 */
#define MAX_INTERRUPT_COUNTER (10 * INTERRUPT_RATE)

/*
 * The 100 Hz counter.
 */
static int volatile Count100Hz = 0;

/*
 * How many 100Hz ticks are yet unhandled?
 */
static atomic_t Unhandled100Hz = ATOMIC_INIT(0);


static struct timeval UserClock;

/**
 * Enumeration of the state of the clock.
 */
enum clock {
    CODED,                   // normal state, clock set from time code inputs
    RESET_COUNTERS,          // need to reset our counters from the clock
    USER_SET_REQUESTED,      // user has requested to set the clock via ioctl
    USER_SET,                // clock was set from user IRIG_SET_CLOCK ioctl
    USER_OVERRIDE_REQUESTED, // user has requested override of clock
    USER_OVERRIDE,           // clock has been overridden
};

/**
 * Current clock state.
 */
static unsigned char volatile ClockState = CODED;

/**
 * Value of extended status from dual port RAM.
 * Bits:
 * 0: 1=On-board clock has not been verified to be within
 *          DP_Syncthr in last 5 seconds
 * 1: 1=Input time code unreadable.
 * 2: 1=PPS pulses not 1 second apart
 * 3: 1=Major time has not been set since counter rejam
 * 4: 1=Year not set
 */
static unsigned char ExtendedStatus =
    DP_Extd_Sts_Nosync | DP_Extd_Sts_Nocode |
    DP_Extd_Sts_NoPPS | DP_Extd_Sts_NoMajT |
    DP_Extd_Sts_NoYear;

static unsigned char LastStatus =
    DP_Extd_Sts_Nosync | DP_Extd_Sts_Nocode |
    DP_Extd_Sts_NoPPS | DP_Extd_Sts_NoMajT |
    DP_Extd_Sts_NoYear;

static unsigned char SyncOK = 0;

/**
 * The year field in the pc104sg time registers
 * ranges from 0-99, so we keep track of the century.
 */
static int StaticYear;

/**
 * Structure of user-opened device
 */
static dev_t DevStart;
static struct cdev Cdev;
struct dsm_clock_sample samp;

static spinlock_t DP_RamLock = SPIN_LOCK_UNLOCKED;
static int DP_RamExtStatusEnabled = 1;
static int DP_RamExtStatusRequested = 0;

/*
 * Interrupt wait timing
 *
 * We wait up to 1.5 * the expected interrupt interval before timing out.
 * By default, we want to use timeouts when waiting for interrupts.
 */
#define INTERRUPT_TIMEOUT_LENGTH ((HZ / INTERRUPT_RATE) * 3 / 2)
static int UseInterruptTimeouts = 1;
static struct timer_list Timeout100Hz_Timer;

/*
 * Workqueue and work_struct stuff
 */
static struct workqueue_struct *WorkQueue100Hz = 0;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
    static void pc104sg_work_100Hz(struct work_struct* work);
    DECLARE_WORK(Work100Hz, pc104sg_work_100Hz);
#else
    static void pc104sg_work_100Hz(void* work);
    DECLARE_WORK(Work100Hz, pc104sg_work_100Hz, NULL);
#endif


/** macros borrowed from glibc/time functions */
#define SECS_PER_HOUR   (60 * 60)

#ifndef SECS_PER_DAY
#define SECS_PER_DAY    (SECS_PER_HOUR * 24)
#endif

/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
#define my_isleap(year)							\
    ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))

#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))
#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))


/**
 * Entry in a callback list.
 */
struct irigCallback {
    struct list_head list;
    irig_callback_t* callback;
    void* privateData;
};

static struct list_head CallbackLists[IRIG_NUM_RATES];

#define CALLBACK_POOL_SIZE 32  /* number of callbacks we can support */
static struct list_head CallbackPool;

static DECLARE_MUTEX(CbListMutex);

/*
 * Operations supported as a character device
 */
static ssize_t pc104sg_read(struct file *filp, char __user *buf,
			    size_t count,loff_t *f_pos);
static unsigned int pc104sg_poll(struct file *filp, poll_table *wait);
static int pc104sg_open(struct inode *inode, struct file *filp);
static int pc104sg_release(struct inode *inode, struct file *filp);
static int pc104sg_ioctl(struct inode *inode, struct file *filp,
			 unsigned int cmd, unsigned long arg);

static struct file_operations pc104sg_fops = {
    .owner   = THIS_MODULE,
    .read    = pc104sg_read,
    .poll    = pc104sg_poll,
    .open    = pc104sg_open,
    .ioctl   = pc104sg_ioctl,
    .release = pc104sg_release,
};


/**
 * Module function that allows other modules to register their callback
 * function to be called at the given rate.  register_irig_callback
 * can be called at (almost) anytime, not just at module init time.
 * The only time that register/unregister_irig_callback cannot be
 * called is from within a callback function itself.
 * A callback function cannot do either register_irig_callback
 * or unregister_irig_callback, otherwise you'll get a deadlock on
 * CbListMutex.
 *
 */
int 
register_irig_callback(irig_callback_t* callback, enum irigClockRates rate,
		       void* privateData)
{
    struct list_head *ptr;
    struct irigCallback* cbentry;

    /* We could do a gpos_malloc of the entry, but that would require
     * that this function be called at module init time.
     * We want it to be call-able at any time, so we
     * gpos_malloc a pool of entries at this module's init time,
     * and grab an entry here.
     */
    down(&CbListMutex);

    ptr = CallbackPool.next;
    if (ptr == &CallbackPool) {          /* none left */
	up(&CbListMutex);
	return -ENOMEM;
    }

    cbentry = list_entry(ptr, struct irigCallback, list);
    list_del(&cbentry->list);

    cbentry->callback = callback;
    cbentry->privateData = privateData;

    list_add(&cbentry->list, CallbackLists + rate);

    up(&CbListMutex);

    return 0;
}

EXPORT_SYMBOL(register_irig_callback);

/**
 * Modules call this function to un-register their callbacks.
 * Note: this cannot be called from within a callback function
 * itself - a callback function cannot register/unregister itself, or
 * any other callback function.  If you try it you will get
 * a deadlock on the CbListMutex.
 */
void 
unregister_irig_callback(irig_callback_t* callback,
			 enum irigClockRates rate, void* privateData)
{
    struct list_head *ptr;
    struct irigCallback *cbentry;

    down(&CbListMutex);

    for (ptr = CallbackLists[rate].next; ptr != CallbackLists + rate;
	 ptr = ptr->next) {
	cbentry = list_entry(ptr, struct irigCallback, list);
	if (cbentry->callback == callback &&
	    (cbentry->privateData == privateData || privateData == 0)) {
	    /* remove it from the list for the rate, and add to the pool. */
	    list_del(&cbentry->list);
	    list_add(&cbentry->list, &CallbackPool);
	    break;
	}
    }

    up(&CbListMutex);
}

EXPORT_SYMBOL(unregister_irig_callback);

/**
 * Cleanup function that un-registers all callbacks.
 */
static void 
free_callbacks(void)
{
    int i;

    struct list_head *ptr;
    struct irigCallback *cbentry;

    down(&CbListMutex);

    for (i = 0; i < IRIG_NUM_RATES; i++) {
	for (ptr = CallbackLists[i].next;
	     ptr != CallbackLists + i; ptr = CallbackLists[i].next) {
	    cbentry = list_entry(ptr, struct irigCallback, list);
	    /* remove it from the list for the rate, and add to the pool. */
	    list_del(&cbentry->list);
	    list_add(&cbentry->list, &CallbackPool);
	}
    }

    for (ptr = CallbackPool.next; ptr != &CallbackPool;
	 ptr = CallbackPool.next) {
	cbentry = list_entry(ptr, struct irigCallback, list);
	list_del(&cbentry->list);
	kfree(cbentry);
    }

    up(&CbListMutex);
}

/**
 * After receiving a heartbeat interrupt, one must reset
 * the heart beat flag in order to receive further interrupts.
 */
static void inline 
ackHeartBeatInt(void)
{
    /* reset heart beat flag, write a 0 to bit 4, leave others alone */
    outb(IntMask & ~Heartbeat, ISA_Address + Status_Port);
}

/**
 * Enable heart beat interrupts
 */
static void 
enableHeartBeatInt(void)
{
    IntMask |= Heartbeat_Int_Enb;
#ifdef DEBUG
    KLOG_DEBUG("IntMask=0x%x\n", IntMask);
#endif
    ackHeartBeatInt();   // reset flag too to avoid immediate interrupt
}

// /**
//  * Disable heart beat interrupts
//  */
// static void 
// disableHeartBeatInt(void)
// {
//     IntMask &= ~Heartbeat_Int_Enb;
//     outb(IntMask, ISA_Address + Status_Port);
// }

/**
 * After receiving a match interrupt, one must reset
 * the match flag in order to receive further interrupts.
 */
static void inline 
ackMatchInt(void)
{
    /* reset match flag, write a 0 to bit 3, leave others alone */
    outb(IntMask & 0xf7, ISA_Address + Status_Port);
}

// /**
//  * Enable external time tag interrupt. These are caused by
//  * a TTL input on a pin, and allows one to tag external
//  * events.  This may be useful for synchronization tests of DSMs.
//  */
// static void 
// enableExternEventInt(void)
// {
//     IntMask |= Ext_Ready_Int_Enb;
//     outb(IntMask, ISA_Address + Status_Port);
// }

// /**
//  * Disable external time tag interrupt.
//  */
// static void 
// disableExternEventInt(void)
// {
//     IntMask &= ~Ext_Ready_Int_Enb;
//     outb(IntMask, ISA_Address + Status_Port);
// }

static void 
disableAllInts(void)
{
    /* disable all interrupts */
    IntMask = 0x1f;
#ifdef DEBUG
    KLOG_DEBUG("IntMask=0x%x\n", IntMask);
#endif
    outb(IntMask, ISA_Address + Status_Port);
}

/**
 * Read dual port RAM.
 * @param addr	dual-port RAM address to read
 */
static int 
ReadDualPortRAM(unsigned char addr, unsigned char* val)
{
    int attempts;
    int waitcount;
    int ret = -1;
    unsigned long flags;
    unsigned char status = 0;
    unsigned long delay_usec = 10; // wait time in microseconds

    spin_lock_irqsave(&DP_RamLock, flags);

    for (attempts = 0; attempts < 10; attempts++)
    {
	if (attempts > 0)
	{
	    /* 
	     * Unlock and wait briefly before regaining the lock and trying
	     * again.
	     */
	    spin_unlock_irqrestore(&DP_RamLock, flags);
	    KLOG_NOTICE("try again\n");
	    udelay(200);
	    spin_lock_irqsave(&DP_RamLock, flags);
	}

	/* clear Response_Ready */
	inb(ISA_Address + Dual_Port_Data_Port);

	/* select dual port address */
	outb(addr, ISA_Address + Dual_Port_Address_Port);
	mb();

	/* 
	 * wait for the PC104SG to acknowledge
	 */
	for (waitcount = 0; waitcount < 10; waitcount++)
	{
	    udelay(delay_usec);
	    status = inb(ISA_Address + Extended_Status_Port);
	    if ((status & Response_Ready) != 0)
		break;
	}

	if (waitcount > 3)
	    KLOG_DEBUG("ReadDualPortRAM, waitcount=%d (* %ld us)\n", 
		       waitcount, delay_usec);

	/* check for a time out on the response... */
	if ((status & Response_Ready) == 0) {
	    KLOG_NOTICE("timed out...\n");
	    continue;
	}

	/* read the requested value */
	*val = inb(ISA_Address + Dual_Port_Data_Port);

	/* success */
	if (attempts > 0)
	    KLOG_NOTICE("done\n");
	ret = 0;
	goto done;
    }
    
    /* failure */
    KLOG_WARNING("failed dual-port read after %d attempts\n", attempts);
    ret = -1;
    
  done:
    spin_unlock_irqrestore(&DP_RamLock, flags);
    return ret;
}


/**
 * The ReqDualPortRAM()/GetDualPortRAM() pair allow us to break a 
 * dual-port read into two parts.  This is used by checkExtendedStatus(),
 * which in turn is used by our interrupt service routine.  Each entry
 * into the ISR reads the value ready from the previous request, then
 * issues another request.  In this way, the necessary delay between
 * requesting dual-port RAM and actually getting the value happens
 * between interrupts, rather than being time spent busy waiting in the
 * interrupt handler itself.
 */
static inline void 
ReqDualPortRAM(unsigned char addr)
{
    /* clear Response_Ready */
    inb(ISA_Address + Dual_Port_Data_Port);

    /* specify dual port address */
    outb(addr, ISA_Address + Dual_Port_Data_Port);
}

static inline void 
GetDualPortRAM(unsigned char* val)
{
   static int ntimeouts = 0;
   unsigned char status;
   status = inb(ISA_Address + Extended_Status_Port);

   /* check for a time out on the response... */
   if (!(status & Response_Ready)) {
      if (!(++ntimeouts % 100))
	  KLOG_WARNING("%d timeouts\n", ntimeouts);
      return;
   }

   /* return read DP_Control value */
   *val = inb(ISA_Address + Dual_Port_Data_Port);
}


/**
 * Set a value in dual port RAM.
 * @param addr	dual-port RAM address to write
 */
static int 
WriteDualPortRAM(unsigned char addr, unsigned char value)
{
    int attempts;
    int waitcount;
    int ret = -1;
    unsigned char status = 0;
    unsigned long flags;
    unsigned long delay_usec = 10; // wait time in microseconds

    spin_lock_irqsave(&DP_RamLock, flags);

    for (attempts = 0; attempts < 10; attempts++)
    {
	if (attempts > 0)
	{
	    spin_unlock_irqrestore(&DP_RamLock, flags);
	    KLOG_NOTICE("try again\n");
	    udelay(200); /* wait briefly before trying again */
	    spin_lock_irqsave(&DP_RamLock, flags);
	}

	/* clear Response_Ready */
	inb(ISA_Address + Dual_Port_Data_Port);

	/* select dual port address */
	outb(addr, ISA_Address + Dual_Port_Address_Port);
	mb();

	/* wait for PC104SG to acknowledge */
	for (waitcount = 0; waitcount < 10; waitcount++)
	{
	    udelay(delay_usec);
	    status = inb(ISA_Address + Extended_Status_Port);
	    if ((status & Response_Ready) != 0)
		break;
	}

	if (waitcount > 3) 
	    KLOG_DEBUG("WriteDualPortRAM 1, waitcount=%d\n", waitcount);

	/* check for a time out on the response... */
	if ((status & Response_Ready) == 0) {
	    KLOG_NOTICE("timed out 1...\n");
	    continue; /* try again */
	}

	/* clear Response_Ready */
	inb(ISA_Address + Dual_Port_Data_Port);

	/* write new value to DP RAM */
	outb(value, ISA_Address + Dual_Port_Data_Port);
	mb();

	for (waitcount = 0; waitcount < 10; waitcount++)
	{
	    udelay(delay_usec);
	    status = inb(ISA_Address + Extended_Status_Port);
	    if ((status & Response_Ready) != 0)
		break;
	}

	if (waitcount > 3) 
	    KLOG_DEBUG("WriteDualPortRAM 2, waitcount=%d\n", waitcount);

	/* check for a time out on the response... */
	if ((status & Response_Ready) == 0) {
	    KLOG_NOTICE("timed out 2...\n");
	    continue; /* try again */
	}

	/*
	 * Wait a bit more here.  Why?  I don't know.  But this (or
	 * a KLOG to print a message here) seems to create enough
	 * delay to make setRate2Output() work properly.
	 */
	udelay(50);

	/* check that the written value matches */
	if (inb(ISA_Address + Dual_Port_Data_Port) != value) {
	    KLOG_WARNING("no match on read-back\n");
	    continue;  /* try again */
	}

	/* success */
	if (attempts > 0)
	    KLOG_NOTICE("done\n");
	ret = 0;
	goto done;
    }


    /* failure */
    KLOG_WARNING("failed dual-port write after %d attempts\n", attempts);
    ret = -1;
    
  done:
    spin_unlock_irqrestore(&DP_RamLock, flags);
    return ret;
}


/* This controls COUNTER 1 on the PC104SG card
 * Since it calls WriteDualPortRAM it may only be called from
 * a real-time thread.
 */
static void 
setHeartBeatOutput(int rate)
{
    int ticks_3MHz;
    int attempts;
    unsigned char lsb, msb;
    unsigned char test;

    ticks_3MHz = 3000000 / rate; // How many ticks of the 3 MHz clock?

    lsb = (unsigned char)(ticks_3MHz & 0xff);
    msb = (unsigned char)(ticks_3MHz >> 8);

    for (attempts = 0; attempts < 10; attempts++)
    {
	if (attempts > 0) 
	{
	    KLOG_NOTICE("try again\n");
	    udelay(100);
	}
	
	WriteDualPortRAM(DP_Ctr1_ctl,
			 DP_Ctr1_ctl_sel | DP_ctl_rw | DP_ctl_mode3 | DP_ctl_bin);
	WriteDualPortRAM(DP_Ctr1_lsb, lsb);
	WriteDualPortRAM(DP_Ctr1_msb, msb);

	ReadDualPortRAM(DP_Ctr1_lsb, &test);
	if (test != lsb)
	{
	    KLOG_WARNING("LSB does not match!\n");
	    continue;
	}
	
	ReadDualPortRAM(DP_Ctr1_msb, &test);
	if (test != msb)
	{
	    KLOG_WARNING("MSB does not match!\n");
	    continue;
	}
	return; // success!
    }

    KLOG_WARNING("failed after %d attempts\n", attempts);
    return;
}

/**
 * Set the primary time reference.
 * @param val 0=PPS is primary time reference, 1=time code is primary
 * Since it calls WriteDualPortRAM it may only be called from
 * a real-time thread.
 */
static void 
setPrimarySyncReference(unsigned char val)
{
    unsigned char control0;
    ReadDualPortRAM(DP_Control0, &control0);

    if (val) 
	control0 |= DP_Control0_CodePriority;
    else 
	control0 &= ~DP_Control0_CodePriority;

#ifdef DEBUG
    KLOG_DEBUG("setting DP_Control0 to 0x%x\n", control0);
#endif
    WriteDualPortRAM(DP_Control0, control0);
}

static void 
setTimeCodeInputSelect(unsigned char val)
{
    WriteDualPortRAM(DP_CodeSelect, val);
}

// static void 
// getTimeCodeInputSelect(unsigned char *val)
// {
//     ReadDualPortRAM(DP_CodeSelect, val);
// }

/* -- Utility --------------------------------------------------------- */

/* 
 * Set the frequency for the Rate2 signal from the card.
 */
void 
setRate2Output(int rate)
{
    int attempts;
    int ticks_3MHz;
    unsigned char lsb, msb;
    unsigned char test;

    KLOG_INFO("setting rate 2 signal frequency to %d Hz\n", rate);
    ticks_3MHz = 3000000 / rate;

    lsb = (unsigned char)(ticks_3MHz & 0xff);
    msb = (unsigned char)(ticks_3MHz >> 8);
    for (attempts = 0; attempts < 10; attempts++)
    {
	if (attempts > 0) 
	{
	    KLOG_NOTICE("try again\n");
	    udelay(100);
	}
	
	WriteDualPortRAM(DP_Ctr0_ctl,
			 DP_Ctr0_ctl_sel | DP_ctl_rw | DP_ctl_mode3 | DP_ctl_bin);
	WriteDualPortRAM(DP_Ctr0_lsb, lsb);
	WriteDualPortRAM(DP_Ctr0_msb, msb);

	ReadDualPortRAM(DP_Ctr0_lsb, &test);
	if (test != lsb)
	{
	    KLOG_WARNING("LSB does not match!\n");
	    continue;
	}

	ReadDualPortRAM(DP_Ctr0_msb, &test);
	if (test != msb)
	{
	    KLOG_WARNING("MSB does not match!\n");
	    continue;
	}
	return; // success!
    }
    
    KLOG_WARNING("failed after %d attempts!\n", attempts);
    return;
}

static void 
counterRejam(void)
{
    WriteDualPortRAM(DP_Command, Command_Rejam);
}

/**
 * Break a struct timeval into the fields of a struct irigTime.
 * This uses some code from glibc/time routines.
 */
static void 
timespec2irig(const struct timespec* ts, struct irigTime* ti)
{
    long int days, rem, y;
    unsigned long int t = ts->tv_sec;

    days = t / SECS_PER_DAY;
    rem = t % SECS_PER_DAY;
    ti->hour = rem / SECS_PER_HOUR;
    rem %= SECS_PER_HOUR;
    ti->min = rem / 60;
    ti->sec = rem % 60;
    y = 1970;

    while (days < 0 || days >= (my_isleap (y) ? 366 : 365))
    {
	/* Guess a corrected year, assuming 365 days per year.  */
	long int yg = y + days / 365 - (days % 365 < 0);

	/* Adjust DAYS and Y to match the guessed year.  */
	days -= ((yg - y) * 365
		 + LEAPS_THRU_END_OF (yg - 1)
		 - LEAPS_THRU_END_OF (y - 1));
	y = yg;
    }
    ti->year = y;
    ti->yday = days + 1; // irig uses 1-366, unix 0-365

    rem = ts->tv_nsec;
    ti->msec = rem / NSECS_PER_MSEC;
    rem %= NSECS_PER_MSEC;
    ti->usec = rem / NSECS_PER_USEC;
    rem %= NSECS_PER_USEC;
    ti->nsec = rem;
}

static void 
timeval2irig(const struct timeval* tv, struct irigTime* ti)
{
    struct timespec ts;
    ts.tv_sec = tv->tv_sec;
    ts.tv_nsec = tv->tv_usec * NSECS_PER_USEC;
    timespec2irig(&ts, ti);
}
/**
 * Convert a struct irigTime into a struct timeval.
 */
static void 
irig2timespec(const struct irigTime* ti, struct timespec* ts)
{
    int y = ti->year;
    int nleap =  LEAPS_THRU_END_OF(y-1) - LEAPS_THRU_END_OF(1969);

    ts->tv_nsec = ti->msec * NSECS_PER_MSEC + ti->usec * NSECS_PER_USEC + 
	ti->nsec;

    ts->tv_sec = (y - 1970) * 365 * SECS_PER_DAY +
	(nleap + ti->yday - 1) * SECS_PER_DAY +
	ti->hour * 3600 + ti->min * 60 + ti->sec;
}

static void 
irig2timeval(const struct irigTime* ti, struct timeval* tv)
{
    struct timespec ts;
    irig2timespec(ti, &ts);
    tv->tv_sec = ts.tv_sec;
    tv->tv_usec = (ts.tv_nsec + NSECS_PER_USEC/2) / NSECS_PER_USEC;
}

/**
 * Read a time from the card.
 * Set offset to 0 to read main clock.
 * Set offset to 0x10 to read time of external pulse.
 *
 * Data are stored in BCD form as 4 byte niblets, containing ones, tens or
 * hundreds value for the respective time fields.
 */
static void 
getTimeFields(struct irigTime* ti, int offset)
{
    unsigned char us0ns2, us2us1, ms1ms0, sec0ms2, min0sec1, hour0min1;
    unsigned char day0hour1, day2day1, year1year0;

    /* reading the Usec1_Nsec100 value latches all other digits */
    us0ns2    = inb(ISA_Address + offset + Usec1_Nsec100_Port);   //0x0f
    us2us1    = inb(ISA_Address + offset + Usec100_Usec10_Port);  //0x0e
    ms1ms0    = inb(ISA_Address + offset + Msec10_Msec1_Port);    //0x0d
    sec0ms2   = inb(ISA_Address + offset + Sec1_Msec100_Port);    //0x0c
    min0sec1  = inb(ISA_Address + offset + Min1_Sec10_Port);      //0x0b
    hour0min1 = inb(ISA_Address + offset + Hr1_Min10_Port);       //0x0a
    day0hour1 = inb(ISA_Address + offset + Day1_Hr10_Port);       //0x09
    day2day1  = inb(ISA_Address + offset + Day100_Day10_Port);    //0x08
    year1year0= inb(ISA_Address + offset + Year10_Year1_Port);    //0x07

    /*
     * Time code inputs do not contain year information.
     * The 10s and 1s digits of year must be initialized by setting
     * DP_Year10_Year (as done in setYear). Otherwise the year defaults to 0.
     *
     * The year field does rollover correctly at the end of the year.
     * Test1:
     * Set major to 1999 Dec 31 23:59 (yday=365, non-leap year)
     * rolled over from year=99, yday=365, to year=0, yday=1
     * Test2:
     * Set major to 2004 Dec 31 23:59 (yday=366, leap)
     * rolled over from year=4, yday=366, to year=5, yday=1
     */

    ti->year = (year1year0 >> 4) * 10 + (year1year0 & 0x0f);

    /* After cold start the year field is not set, and it
     * takes some time before the setYear to DPR takes effect.
     * I saw values of 165 for the year during this time.
     */
    if (ExtendedStatus & DP_Extd_Sts_NoYear) {
	// KLOG_DEBUG("fixing year=%d to %d\n", ti->year, StaticYear);
	ti->year = StaticYear;
    }
    // This has a Y2K problem, but who cares - it was written in 2004 and
    // it's for a real-time data system!
    else 
	ti->year += (StaticYear / 100) * 100;

    ti->yday = ((day2day1 >> 4) * 100) + ((day2day1 & 0x0f) * 10) +
	(day0hour1 >> 4);
    ti->hour = (day0hour1 & 0x0f) * 10 + (hour0min1 >> 4);
    ti->min = (hour0min1 & 0x0f) * 10 + (min0sec1 >> 4);
    ti->sec = (min0sec1 & 0x0f) * 10 + (sec0ms2 >> 4);
    ti->msec = ((sec0ms2 & 0x0f) * 100) + ((ms1ms0 >> 4) * 10) +
	(ms1ms0 & 0x0f);
    ti->usec = ((us2us1 >> 4) * 100) + ((us2us1 & 0x0f) * 10) + (us0ns2 >> 4);
    ti->nsec = (us0ns2 & 0x0f) * 100;
}

/**
 * Read sub-second time fields from the card, return microseconds.
 * May be useful for watching-the-clock when debugging.
 */
long 
getTimeUsec()
{
    unsigned char us0ns2, us2us1, ms1ms0, sec0ms2;
    long usec;

    /* reading the Usec1_Nsec100 value latches all other digits */
    us0ns2    = inb(ISA_Address + Usec1_Nsec100_Port);
    us2us1    = inb(ISA_Address + Usec100_Usec10_Port);
    ms1ms0    = inb(ISA_Address + Msec10_Msec1_Port);
    sec0ms2   = inb(ISA_Address + Sec1_Msec100_Port);

    usec = (((sec0ms2 & 0x0f) * 100) + ((ms1ms0 >> 4) * 10) +
	    (ms1ms0 & 0x0f)) * USECS_PER_MSEC +
	((us2us1 >> 4) * 100) + ((us2us1 & 0x0f) * 10) + (us0ns2 >> 4);
    return usec;
}

/**
 * Get main clock.
 */
static void 
getCurrentTime(struct irigTime* ti)
{
    getTimeFields(ti, 0);
#ifdef DEBUG
    {
	int td, hr, mn, sc;
	// unsigned char status = inb(ISA_Address + Status_Port);
	dsm_sample_time_t tt = GET_MSEC_CLOCK;
	struct timespec ts;
	irig2timespec(ti, &ts);
	// clock difference
	td = (ts.tv_sec % SECS_PER_DAY) * MSECS_PER_SEC +
	    ts.tv_nsec / NSECS_PER_MSEC - tt;
	hr = (tt / 3600 / MSECS_PER_SEC);
	tt %= (3600 * MSECS_PER_SEC);
	mn = (tt / 60 / MSECS_PER_SEC);
	tt %= (60 * MSECS_PER_SEC);
	sc = tt / MSECS_PER_SEC;
	tt %= MSECS_PER_SEC;
	KLOG_DEBUG("%04d %03d %02d:%02d:%02d.%03d %03d %03d, "
		   "clk=%02d:%02d:%02d.%03d, diff=%d, estat=0x%x, state=%d\n",
		   ti->year, ti->yday, ti->hour, ti->min, ti->sec, ti->msec, 
		   ti->usec, ti->nsec, hr, mn, sc, (int)tt, td, 
		   ExtendedStatus, ClockState);
    }
#endif
}

/* this function is available for external use */
void 
irig_clock_gettime(struct timespec* tp)
{
    struct irigTime it;
    getTimeFields(&it, 0);
    irig2timespec(&it, tp);
}

/* this function is available for external use */
int 
get_msec_clock_resolution()
{
    return MSEC_PER_INTERRUPT;
}

// /**
//  * Get external event time.
//  */
// static void 
// getExtEventTime(struct irigTime* ti) {
//     return getTimeFields(ti, 0x10);
// }

/**
 * set the year fields in Dual Port RAM.
 */
static void 
setYear(int val)
{
    StaticYear = val;
#ifdef DEBUG
    KLOG_DEBUG("setYear=%d\n", val);
#endif
    WriteDualPortRAM(DP_Year1000_Year100,
		   ((val / 1000) << 4) + ((val % 1000) / 100));
    val %= 100;
    WriteDualPortRAM(DP_Year10_Year1, ((val / 10) << 4) + (val % 10));

    WriteDualPortRAM(DP_Command, Command_Set_Years);
}

/**
 * The major time consists of the day-of-year, hour, minute
 * and second fields.  Ideally they are set via the time-code
 * input, but this function can be used if there is no time-code.
 *
 * The sub-second values are determined from the PPS input,
 * and I see no ways to change them if there is no PPS or time-code.
 */
static int 
setMajorTime(struct irigTime* ti)
{
    int val;

#ifdef DEBUG
    // unsigned char status = inb(ISA_Address + Status_Port);
    KLOG_DEBUG("setMajor=%04d %03d %02d:%02d:%02d.%03d %03d %03d, "
	       "estat=0x%x, state=%d\n",
	       ti->year, ti->yday, ti->hour, ti->min, ti->sec, ti->msec, 
	       ti->usec, ti->nsec, ExtendedStatus, ClockState);
#endif
    /* The year fields in Dual Port RAM are not technically
     * part of the major time, but we'll set them too.  */
    setYear(ti->year);

    val = ti->yday;
    WriteDualPortRAM(DP_Major_Time_d100, val / 100);
    val %= 100;
    WriteDualPortRAM(DP_Major_Time_d10d1, ((val / 10) << 4) + (val % 10));
    
    val = ti->hour;
    WriteDualPortRAM(DP_Major_Time_h10h1, ((val / 10) << 4) + (val % 10));
    
    val = ti->min;
    WriteDualPortRAM(DP_Major_Time_m10m1, ((val / 10) << 4) + (val % 10));

    val = ti->sec;
    WriteDualPortRAM(DP_Major_Time_s10s1, ((val / 10) << 4) + (val % 10));

    WriteDualPortRAM(DP_Command, Command_Set_Major);

    return 0;
}

/**
 * Increment our clock by a number of ticks.
 */
static void inline 
increment_clock(int tick)
{
    unsigned char c;
    
    MsecClockTicker += tick;
    MsecClockTicker %= MSECS_PER_DAY;

    /*
     * This little double clock provides a clock that can be
     * read by external modules without needing a mutex.
     * It ensures that MsecClock[ReadClock]
     * is valid for at least an interrupt period after reading the
     * value of ReadClock, even if this code is pre-emptive.
     *
     * This clock is incremented at the interrupt rate.
     * If somehow a bogged down piece of code reads the value of
     * ReadClock, and then didn't get around to reading
     * MsecClock[ReadClock] until more than an interrupt period
     * later then it could read a half-written value, but that
     * ain't gunna happen.
     */
    MsecClock[WriteClock] = MsecClockTicker;
    c = ReadClock;
    /* prior to this line MsecClock[ReadClock=0] is  OK to read */
    ReadClock = WriteClock;
    /* now MsecClock[ReadClock=1] is still OK to read. We're assuming
     * that the byte write of ReadClock is atomic.
     */
    WriteClock = c;
}

static inline void 
incrementCount100Hz(void)
{
    if (++Count100Hz == MAX_INTERRUPT_COUNTER) Count100Hz = 0;
    atomic_inc(&Unhandled100Hz);
}

/**
 * Set the clock and 100 hz counter based on the time in a time val struct.
 */
static void 
setCounters(struct timeval* tv)
{
#ifdef DEBUG
    int td = (tv->tv_sec % SECS_PER_DAY) * MSECS_PER_SEC +
	tv->tv_usec / USECS_PER_MSEC - MsecClockTicker;
#endif

    MsecClockTicker =
	(tv->tv_sec % SECS_PER_DAY) * MSECS_PER_SEC +
	(tv->tv_usec + USECS_PER_MSEC/2) / USECS_PER_MSEC;
    MsecClockTicker -= MsecClockTicker % MSEC_PER_INTERRUPT;
    MsecClockTicker %= MSECS_PER_DAY;

    Count100Hz = MsecClockTicker / MSEC_PER_CALLBACK_CHECK;
    if (!(MsecClockTicker % MSEC_PER_CALLBACK_CHECK)
	&& (Count100Hz-- == 0)) Count100Hz = MAX_INTERRUPT_COUNTER - 1;
    Count100Hz %= MAX_INTERRUPT_COUNTER;

#ifdef DEBUG
    KLOG_DEBUG("tv=%ld.%06ld, MsecClockTicker=%lu, td=%d, Count100Hz=%d\n",
	       tv->tv_sec, tv->tv_usec, MsecClockTicker, td, 
	       Count100Hz);
#endif
}

/**
 * Update the clock counters to the current time.
 */
static inline void 
setCountersToClock(void)
{
    // reset counters to clock
    struct irigTime ti;
    struct timeval tv;
    getCurrentTime(&ti);
    irig2timeval(&ti, &tv);
    setCounters(&tv);
}

/**
 * Invoke the callback functions for a given rate.
 */
static inline void 
doCallbacklist(struct list_head* list)
{
    struct list_head *ptr;
    struct irigCallback *cbentry;

    for (ptr = list->next; ptr != list; ptr = ptr->next) {
	cbentry = list_entry(ptr, struct irigCallback, list);
	cbentry->callback(cbentry->privateData);
    }
}

/**
 * Work to do on a 100 Hz basis, which performs requested regular
 * callbacks.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
static void 
pc104sg_work_100Hz(struct work_struct* unused)
#else
static void 
pc104sg_work_100Hz(void* unused)
#endif
{
    int nhandled;

#ifdef NOTDEF /* timeout not implemented for workqueue yet */
    /*
     * (maybe) schedule a timeout on waiting for the next interrupt
     */
    if (UseInterruptTimeouts) 
    {
	Timeout100Hz_Timer.expires = jiffies + INTERRUPT_TIMEOUT_LENGTH;
	add_timer(&Timeout100Hz_Timer);
    }
#endif

    /*
     * Now handle all the unhandled 100Hz actions
     */
    for (nhandled = 0; atomic_read(&Unhandled100Hz) > 0; 
	 nhandled++, atomic_dec(&Unhandled100Hz))
    {
	// lock the callback list
	down(&CbListMutex);

	/* perform 100Hz processing... */
	doCallbacklist(CallbackLists + IRIG_100_HZ);

	if ((Count100Hz % 2)) goto _5;

	/* perform 50Hz processing... */
	doCallbacklist(CallbackLists + IRIG_50_HZ);

	if ((Count100Hz % 4)) goto _5;

	/* perform 25Hz processing... */
	doCallbacklist(CallbackLists + IRIG_25_HZ);

      _5:
	if ((Count100Hz % 5)) goto cleanup;

	/* perform 20Hz processing... */
	doCallbacklist(CallbackLists + IRIG_20_HZ);

	if ((Count100Hz % 10)) goto _25;

	/* perform 10Hz processing... */
	doCallbacklist(CallbackLists + IRIG_10_HZ);

	if ((Count100Hz % 20)) goto _25;

	/* perform  5Hz processing... */
	doCallbacklist(CallbackLists + IRIG_5_HZ);

      _25:
	if ((Count100Hz % 25)) goto cleanup;

	/* perform  4Hz processing... */
	doCallbacklist(CallbackLists + IRIG_4_HZ);

	if ((Count100Hz % 50)) goto cleanup;

	/* perform  2Hz processing... */
	doCallbacklist(CallbackLists + IRIG_2_HZ);

	if ((Count100Hz % 100)) goto cleanup;

	/* perform  1Hz processing... */
	doCallbacklist(CallbackLists + IRIG_1_HZ);

	if ((Count100Hz % 1000)) goto cleanup;

	/* perform  0.1 Hz processing... */
	doCallbacklist(CallbackLists + IRIG_0_1_HZ);

      cleanup:
	up(&CbListMutex);
    }

    if (nhandled >= 20)
	KLOG_NOTICE("%d 100Hz ticks handled at once @ %ld\n", nhandled,
		    GET_MSEC_CLOCK);
}

/*
 * Check the extended status byte.
 * If clock status has changed adjust our clock counters.
 * This function is called by the interrupt service routine
 * and so we don't have to worry about simultaneous access
 * when changing the clock counters.
 */
static inline void 
checkExtendedStatus(void)
{
    /* 
     * Finish read of extended status from dual-port RAM and submit the next
     * request for extended status.
     *
     * Infrequently the user sends ioctl's which also access dual-port
     * RAM. The spin_locks are used to avoid simultaneous access.
     */
    spin_lock(&DP_RamLock);

    if (DP_RamExtStatusRequested)
    {
	GetDualPortRAM(&ExtendedStatus);
	DP_RamExtStatusRequested = 0;
    }

    /* send next request */
    if (DP_RamExtStatusEnabled)
    {
	ReqDualPortRAM(DP_Extd_Sts);
	DP_RamExtStatusRequested = 1;
    }

    spin_unlock(&DP_RamLock);

    /*
     * This is where we can change clock state
     */
    switch (ClockState) {
      case USER_OVERRIDE_REQUESTED:
	setCounters(&UserClock);
	ClockState = USER_OVERRIDE;
	break;
      case USER_SET_REQUESTED:
	// has requested to set the clock, and we
	// have no time code: then set the clock counters
	// by the user clock
	if ((LastStatus & DP_Extd_Sts_Nocode) &&
	    (ExtendedStatus & DP_Extd_Sts_Nocode)) {
            setCounters(&UserClock);
            ClockState = USER_SET;
	}
	// ignore request since we have time code
	else ClockState = CODED;
	break;
      case USER_SET:
	if ((LastStatus & DP_Extd_Sts_Nocode) == 0 &&
	    (ExtendedStatus & DP_Extd_Sts_Nocode) == 0) {
            // have good clock again, set counters back to coded clock
            ClockState = RESET_COUNTERS;
	}
	break;
      case RESET_COUNTERS:
      case USER_OVERRIDE:
      case CODED:
	break;
    }
    /* At this point ClockState is either
     * CODED: we're going with whatever the hardware clock says
     * RESET_COUNTERS: need to reset our counters to hardware clock
     * USER_OVERRIDE: user has overridden the clock
     *           In this case the hardware clock doesn't
     *           match our own counters.
     * USER_SET: the clock has been set from an ioctl with setMajorTime(),
     *          and time code input is missing.  Since the
     *           timecode is missing, the counters will be within
     *          a second of the hardware clock.
     */

    /* Bits in extended status:
     * bit 0:  0=clock sync'd to PPS or time code. This means
     *           the sub-second fields are OK.
     *         1=clock not sync'd.
     * bit 1:  0=time code inputs OK (day,hr,min,sec fields OK)
     *         1=time code inputs not readable. In this case
     *           the pc104sg keeps incrementing its own clock
     *           starting from whatever was set in the major time fields.
     * bit 2:  0=PPS inputs OK
     *         1=PPS inputs not readable
     */
    // transition from no sync to sync, reset the counters
    if (ClockState == CODED &&
	(LastStatus & DP_Extd_Sts_Nosync) &&
	((ExtendedStatus & DP_Extd_Sts_Nosync) == 0))
	ClockState = RESET_COUNTERS;

    if (ClockState == RESET_COUNTERS) {
	setCountersToClock();
	ClockState = CODED;
    }
    LastStatus = ExtendedStatus;
}

/*
 * Handle heartbeat interrupts.  This function can be called with an
 * IRQ of zero to indicate that a timeout occurred waiting for an
 * interrupt.
 */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
static irqreturn_t 
pc104sg_isr(int irq, void* callbackPtr)
#else
static irqreturn_t 
pc104sg_isr(int irq, void* callbackPtr, struct pt_regs *regs)
#endif
{
    unsigned char status = inb(ISA_Address + Status_Port);
    static int consecutiveTimeouts = 0;
    static int entrycount = 0;
    SyncOK = status & Sync_OK;

    /*
     * If the IRQ is zero, we were called as a result of a timeout,
     * and not a real h/w interrupt.
     */
    if (irq == 0) 
    {
	consecutiveTimeouts++;
	if (consecutiveTimeouts <= 10 || !(consecutiveTimeouts % 100)) 
	    KLOG_NOTICE("%d consecutive timeouts\n", consecutiveTimeouts);
    }
    else
	consecutiveTimeouts = 0;

    if ((status & Heartbeat) && (IntMask & Heartbeat_Int_Enb)) {

	/* acknowledge interrupt (essential!) */
	ackHeartBeatInt();

	increment_clock(MSEC_PER_INTERRUPT);

	checkExtendedStatus();

	/*
	 * Reset the timeout timer
	 */
	if (UseInterruptTimeouts) 
	    mod_timer(&Timeout100Hz_Timer, jiffies + INTERRUPT_TIMEOUT_LENGTH);

	/*
	 * On 10 millisecond intervals, schedule our 100Hz work.
	 */
	if (!(MsecClockTicker % MSEC_PER_CALLBACK_CHECK)) {
	    incrementCount100Hz();
	    queue_work(WorkQueue100Hz, &Work100Hz);
	}

    }
#ifdef CHECK_EXT_EVENT
    if ((status & Ext_Ready) && (IntMask & Ext_Ready_Int_Enb)) {
	struct irigTime ti;
	getExtEventTime(&ti);
	KLOG_DEBUG("ext event=%04d %03d %02d:%02d:%02d.%03d %03d %03d, "
		   "stat=0x%x, state=%d\n", ti.year, ti.yday, ti.hour, 
		   ti.min, ti.sec, ti.msec, ti.usec, ti.nsec, 
		   ExtendedStatus, ClockState);
    }
#endif
    entrycount++;
    return 0;
}

static void
timeoutHandler(unsigned long unused)
{
    /*
     * Just call the interrupt handler with an IRQ of zero to 
     * indicate that a timeout occurred.
     */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
    pc104sg_isr(0, NULL);
#else
    pc104sg_isr(0, NULL, NULL);
#endif
}

/*
 * This function is registered to be called every second for each currently
 * open access to the IRIG device.  It gets the current clock value and
 * makes it available for the user to read.
 */
static void 
writeTimeCallback(void* irigPortPtr)
{
    struct irig_port* p = (struct irig_port*) irigPortPtr;
    struct irigTime ti;
    dsm_sample_time_t tt = GET_MSEC_CLOCK;

    down_interruptible(&p->lock);

    getCurrentTime(&ti);
    
    // check clock sanity
    if (ClockState == CODED || ClockState == USER_SET) {
	struct timeval tv;
	int td;

	irig2timeval(&ti, &tv);
	// clock difference
	td = (tv.tv_sec % SECS_PER_DAY) * MSECS_PER_SEC +
	    tv.tv_usec / USECS_PER_MSEC - tt;
	/* If not within 3 milliseconds, ask to reset counters.
	 * Since this is being called as a 1 Hz callback some
	 * time may have elapsed since the 100 Hz interrupt.
	 */
	if (abs(td) > 3) 
	    ClockState = RESET_COUNTERS;
    }

    p->samp.timetag = tt;
    p->samp.length = sizeof(p->samp.data.tval) +
	sizeof(p->samp.data.status);

    irig2timeval(&ti, &p->samp.data.tval);
    p->samp.data.status = ExtendedStatus;
    if (!SyncOK) p->samp.data.status |= CLOCK_SYNC_NOT_OK;

#ifdef DEBUG
    KLOG_DEBUG("tv_secs=%d, tv_usecs=%d status=0x%x\n",
	       (int)p->samp.data.tval.tv_sec, 
	       (int)p->samp.data.tval.tv_usec,
	       p->samp.data.status);
#endif

    p->readyForRead = 1;
    up(&p->lock);
/*
 * Wake up those who might be waiting to read
 */
    wake_up_interruptible(&(p->rwaitq));
}


/* -- MODULE ---------------------------------------------------------- */
void 
pc104sg_cleanup(void)
{
#ifdef DEBUG
    KLOG_DEBUG("cleaning up\n");
    KLOG_NOTICE("unregister_chrdev_region\n");
#endif
    unregister_chrdev_region(DevStart, 1);

#ifdef DEBUG
    KLOG_NOTICE("delete IRIG cdev\n");
#endif
    cdev_del(&Cdev);

#ifdef DEBUG
    KLOG_NOTICE("free_callbacks\n");
#endif
    /* free up our pool of callbacks */
    free_callbacks();

#ifdef DEBUG
    KLOG_NOTICE("disableAllInts\n");
#endif
    disableAllInts();

    del_timer_sync(&Timeout100Hz_Timer);
    flush_workqueue(WorkQueue100Hz);
    destroy_workqueue(WorkQueue100Hz);

#ifdef DEBUG
    KLOG_NOTICE("free_irq\n");
#endif
    free_irq(Irq, (void*)IRQ_DEVID);

    /* free up the I/O region and remove /proc entry */
#ifdef DEBUG
    KLOG_NOTICE("release_region\n");
#endif
    if (ISA_Address)
	release_region(ISA_Address, PC104SG_IOPORT_WIDTH);

    KLOG_NOTICE("done\n");
}

/* -- MODULE ---------------------------------------------------------- */
/* activate the pc104sg-B board */

int 
pc104sg_init(void)
{
    int i;
    int errval = 0;
    int got_irq = 0;
    int newIrq;

    /* 
     * If our timeout for interrupts is less than 2 jiffies, then the
     * timeouts are likely to occur before the interrupts can
     * arrive to cancel them.  In this case, we just disable the
     * timeout mechanism.
     */
    if (INTERRUPT_TIMEOUT_LENGTH < 2) 
    {
	KLOG_INFO("Kernel HZ value of %d with IRIG interrupt rate "
		  "of %d Hz\n", HZ, INTERRUPT_RATE);
	KLOG_INFO("PC104-SG IRIG interrupt timeouts disabled "
		  "because HZ is too small\n");
	UseInterruptTimeouts = 0;
    }

    INIT_LIST_HEAD(&CallbackPool);
    for (i = 0; i < IRIG_NUM_RATES; i++)
	INIT_LIST_HEAD(CallbackLists + i);

    /* check for module parameters */
    ISA_Address = (unsigned int)IoPort + SYSTEM_ISA_IOPORT_BASE;

    errval = -EBUSY;
    /* Grab the region so that no one else tries to probe our ioports. */
    if (! request_region(ISA_Address, PC104SG_IOPORT_WIDTH, "pc104sg"))
	goto err0;

    /* initialize clock counters that external modules grab */
    ReadClock = 0;
    WriteClock = 0;
    MsecClock[ReadClock] = 0;
    MsecClock[WriteClock] = 0;

    /* shutoff pc104sg interrupts just in case */
    disableAllInts();

    /* create our pool of callback entries */
    errval = -ENOMEM;
    for (i = 0; i < CALLBACK_POOL_SIZE; i++) {
	struct irigCallback* cbentry =
	    (struct irigCallback*) kmalloc(sizeof(struct irigCallback),
					   GFP_KERNEL);
	if (!cbentry) goto err0;
	list_add(&cbentry->list, &CallbackPool);
    }

    /*
     * Allow for ISA interrupts to be remapped for some processors
     */
    newIrq = GET_SYSTEM_ISA_IRQ(Irq);
    if (newIrq != Irq)
    {
	KLOG_NOTICE("ISA IRQ %d remapped to IRQ %d for this processor\n", 
		    Irq, newIrq);
	Irq = newIrq;
    }

    errval = request_irq(Irq, pc104sg_isr, SA_SHIRQ, "PC104-SG IRIG", 
			 (void*)IRQ_DEVID);
    if (errval < 0) {
	/* failed... */
	KLOG_ERR("could not allocate IRQ %d\n", Irq);
	goto err0;
    }
    else 
    {
#ifdef DEBUG
	KLOG_DEBUG("got IRQ %d\n", Irq);
#endif
    }

    got_irq = 1;

    /*
     * Initialize our interrupt timeout timer
     */
    init_timer(&Timeout100Hz_Timer);
    Timeout100Hz_Timer.function = timeoutHandler;
    Timeout100Hz_Timer.data = 0;

    /*
     * Initialize and add the user-visible device
     */
    if ((errval = alloc_chrdev_region(&DevStart, 0, 1, "irig")) < 0)
    {
	KLOG_ERR("Error %d allocating device major number for 'irig'\n",
		 -errval);
        goto err0;
    }
    else
	KLOG_NOTICE("Got major device number %d for 'irig'\n", 
		    MAJOR(DevStart));
    
    cdev_init(&Cdev, &pc104sg_fops);
    if ((errval = cdev_add(&Cdev, DevStart, 1)) < 0)
    {
	KLOG_ERR("cdev_add() for PC104SG failed!\n");
	goto err0;
    }

    /*
     * Set up the workqueue
     */
    WorkQueue100Hz = create_singlethread_workqueue("pc104sg");
    if (! WorkQueue100Hz)
    {
	KLOG_ERR("Failed to create workqueue!\n");
	goto err0;
    }

    /* 
     * IRIG-B is the default, but we'll set it anyway 
     */
    setTimeCodeInputSelect(DP_CodeSelect_IRIGB);
    setPrimarySyncReference(0);     // 0=PPS, 1=timecode

    /*
     * Set the internal heart-beat and rate2 to be in phase with
     * the PPS/time_code reference
     */
    setHeartBeatOutput(INTERRUPT_RATE);
    setRate2Output(A2DClockFreq);
    counterRejam();

    ClockState = RESET_COUNTERS;

    /*
     * Initialize the first request for extended status from dual-port
     * RAM.  The value will be read and successive requests will be 
     * issued by checkExtendedStatus()
     */
    if (DP_RamExtStatusEnabled)
    {
	ReqDualPortRAM(DP_Extd_Sts);
	DP_RamExtStatusRequested = 1;
    }

    /* start interrupts */
    enableHeartBeatInt();
	
    return 0;

  err0:

    del_timer_sync(&Timeout100Hz_Timer);

    if (WorkQueue100Hz)
    {
	flush_workqueue(WorkQueue100Hz);
	destroy_workqueue(WorkQueue100Hz);
    }
   
    /* free up our pool of callbacks */
    free_callbacks();

    disableAllInts();

    if (got_irq) free_irq(Irq, (void*)IRQ_DEVID);

    /* free up the I/O region and remove /proc entry */
    if (ISA_Address)
	release_region(ISA_Address, PC104SG_IOPORT_WIDTH);

    return errval;
}

/*
 * Implementation of poll fops.
 */
static unsigned int 
pc104sg_poll(struct file *filp, poll_table *wait)
{
    struct irig_port *p = (struct irig_port*)filp->private_data;
    unsigned int mask = 0;
    if (down_interruptible(&p->lock))
	return -ERESTARTSYS;
    poll_wait(filp, &p->rwaitq, wait);
    if (p->readyForRead) mask |= POLLIN | POLLRDNORM;    /* readable */
    up(&p->lock);
    return mask;
}

/*
 * User-side read function
 */
static ssize_t 
pc104sg_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
    struct irig_port *p = (struct irig_port*)filp->private_data;
    int dsmSampleSize = SIZEOF_DSM_SAMPLE_HEADER + p->samp.length;
    int retval = 0;
    int n;

    if (down_interruptible(&p->lock))
	return -ERESTARTSYS;
    /*
     * Wait (or return for non-blocking read) if data aren't ready
     */
    while (! p->readyForRead)
    {
	up(&p->lock);
	/*
	 * Return now for a non-blocking read
	 */
	if (filp->f_flags & O_NONBLOCK)
	    return -EAGAIN;
	/*
	 * Wait for data to be ready
	 */
	if (wait_event_interruptible(p->rwaitq, (p->readyForRead != 0)))
	    return -ERESTARTSYS;
	/*
	 * Regain our lock on the dev 
	 */
	if (down_interruptible(&p->lock))
	    return -ERESTARTSYS;
    }
    
    n = (count > dsmSampleSize) ? dsmSampleSize : count;
    retval = copy_to_user(buf, &(p->samp), n) ? -EFAULT : n;

    p->readyForRead = 0;
    up(&p->lock);
    return retval;
}

static int 
pc104sg_open(struct inode *inode, struct file *filp)
{
    struct irig_port *p = 
	(struct irig_port*) kmalloc(sizeof(struct irig_port), GFP_KERNEL);
    int errval;

    p->readyForRead = 0;
    init_waitqueue_head(&p->rwaitq);
    sema_init(&p->lock, 1);

    /*
     * Register the 1 Hz callback to write times to user-opened device(s)
     */
    errval = register_irig_callback(writeTimeCallback, IRIG_1_HZ, p);
    if (errval < 0) 
    {
	KLOG_ERR("Error %d registering callback\n", -errval);
	kfree(p);
	return errval;
    }

    filp->private_data = p;
    return 0;
}

static int 
pc104sg_release(struct inode *inode, struct file *filp)
{
    struct irig_port *p = (struct irig_port*)filp->private_data;
    unregister_irig_callback(writeTimeCallback, IRIG_1_HZ, p);

    kfree(p);
    return 0;
}

static int 
pc104sg_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, 
	      unsigned long arg)
{
    void __user* userptr = (void __user*)arg;
    int len = _IOC_SIZE(cmd);
    int ret = -EINVAL;
    struct irigTime ti;
    struct timeval tv;
    unsigned long flags;

#ifdef DEBUG
    KLOG_DEBUG("cmd=0x%x\n", cmd);
#endif
    
    /*
     * Make sure the ioctl command is one of ours
     */
    if (_IOC_TYPE(cmd) != IRIG_IOC_MAGIC)
	return -EINVAL;

    /*
     * Verify read or write access to the user arg, if necessary
     */
    if ((_IOC_DIR(cmd) & _IOC_READ) && 
	! access_ok(VERIFY_WRITE, userptr, len))
	return -EFAULT;

    if ((_IOC_DIR(cmd) & _IOC_WRITE) && 
	! access_ok(VERIFY_READ, userptr, len))
	return -EFAULT;
	 

    ret = -EFAULT;

    switch (cmd) 
    {
      case IRIG_GET_STATUS:
	if (len != sizeof(ExtendedStatus)) 
	    break;
	ret = copy_to_user(userptr, &ExtendedStatus, len) ? -EFAULT : len;
	break;
      case IRIG_GET_CLOCK:
	if (len != sizeof(tv)) 
	    break;
	getCurrentTime(&ti);
	irig2timeval(&ti, &tv);
	ret = copy_to_user(userptr, &tv, sizeof(tv)) ? -EFAULT : len;
	break;
      case IRIG_SET_CLOCK:
	if (len != sizeof(UserClock)) 
	    break;

	ret = copy_from_user(&UserClock, userptr, sizeof(UserClock)) ? 
	    -EFAULT : len;
	if (ret < 0)
	    break;

	timeval2irig(&UserClock, &ti);

	spin_lock_irqsave(&DP_RamLock, flags);
	DP_RamExtStatusEnabled = 0;
	spin_unlock_irqrestore(&DP_RamLock, flags);

	if (ExtendedStatus & DP_Extd_Sts_Nocode) 
	    setMajorTime(&ti);
	else
	    setYear(ti.year);

	spin_lock_irqsave(&DP_RamLock, flags);
	DP_RamExtStatusEnabled = 1;
	spin_unlock_irqrestore(&DP_RamLock, flags);

	ClockState = USER_SET_REQUESTED;
	break;
      case IRIG_OVERRIDE_CLOCK:
	if (len != sizeof(UserClock)) 
	    break;

	ret = copy_from_user(&UserClock, userptr, sizeof(UserClock)) ? 
	    -EFAULT : len;
	if (ret < 0)
	    break;
	
	timeval2irig(&UserClock, &ti);

	spin_lock_irqsave(&DP_RamLock, flags);
	DP_RamExtStatusEnabled = 0;
	spin_unlock_irqrestore(&DP_RamLock, flags);

	if (ExtendedStatus & DP_Extd_Sts_Nocode)
	    setMajorTime(&ti);
	else
	    setYear(ti.year);

	spin_lock_irqsave(&DP_RamLock, flags);
	DP_RamExtStatusEnabled = 1;
	spin_unlock_irqrestore(&DP_RamLock, flags);

	ClockState = USER_OVERRIDE_REQUESTED;
	ret = len;
	break;
      default:
	KLOG_WARNING("Unrecognized ioctl %d (number %d, size %d)\n", cmd,
		     _IOC_NR(cmd), _IOC_SIZE(cmd));
	ret = -EINVAL;
	break;
    }
    
    return ret;
}


module_init(pc104sg_init);
module_exit(pc104sg_cleanup);
