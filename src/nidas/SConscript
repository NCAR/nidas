# -*- python -*-

##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

##
##  Import the build environment.
##
Import('env')
arch = env['ARCH']

# Use the OTHER_ prefix only if it exists and is different than PREFIX
if env.has_key('OTHER_PREFIX') and env['PREFIX'] != env['OTHER_PREFIX']:
    import os
    other_include = env.subst("$OTHER_PREFIX/include")
    other_lib = env.subst("$OTHER_PREFIX/lib")
    if os.path.exists(other_include):
        env.AppendUnique(CPPPATH = [ other_include ])
    if os.path.exists(other_lib):
        env.AppendUnique(LIBPATH = [ other_lib ])

# libnidas.so is built with -lnidas_util option, and so libnidas.so
# has an internal dependency on libnidas_util.so.  Because of this,
# when linking against libnidas.so, you don't have to specify -lnidas_util.
#
# However, when ld is resolving these internal dependencies between
# shared libraries it does not search the -Ldir (LIBPATH) directories.
# Instead it searches these paths: -rpath-link, -rpath, $LD_RUN_PATH,
# $LD_LIBRARY_PATH, $DT_RUN_PATH,$DT_RPATH,/lib,/usr/lib and ld.so.conf.
# See man ld, under -rpath-link.
#
# Hence these -rpath-link options to search the build directories
# at link time.  Note that the run-time linker does not use
# -rpath-link, it uses -rpath
#
# -rdynamic: Export all dynamic symbols in the executables, so that libraries
# loaded with dlopen() can resolve symbols already in the executable.
env.AppendUnique(LINKFLAGS=['-rdynamic'] +
    ['-Xlinker','-rpath-link','-Xlinker',env.Dir("build_dynld")] +
    ['-Xlinker','-rpath-link','-Xlinker',env.Dir("build_core")] +
    ['-Xlinker','-rpath-link','-Xlinker',env.Dir("build_util")])

# If LIBPATH is not needed, initialize to empty list so
# that env['LIBPATH'] doesn't fail in SConscripts
env.Append(LIBPATH = []);

# env.Append(LIBS = ['XmlRpc'])
# env.Append(LIBPATH = [env.subst('$PREFIX/lib')])

# To decipher the link statement:
# print 'LINKCOM=' + str(env['LINKCOM'])
# print '_LIBDIRFLAGS=' + str(env['_LIBDIRFLAGS'])
# print '_LIBFLAGS=' + str(env['_LIBFLAGS'])

# Check for headers and libraries
conf = Configure(env)
if conf.CheckCHeader('sys/capability.h'):
    conf.env.Append(CPPDEFINES = 'HAS_CAPABILITY_H')
if conf.CheckLib('cap'):
    conf.env.AppendUnique(LIBS = 'cap')
env = conf.Finish()

subdirs=Split("""util core dynld apps linux rtlinux""")

for dir in subdirs:
    SConscript('%s/SConscript' % dir,
               build_dir='build_%s' % dir,
               duplicate=0,exports={'env':env})

##
## ARCH target for creating modules, library, and executables
##

Alias(arch, ['build_%s' % dir for dir in subdirs])
Alias('lib', ['build_%s' % d for d in subdirs[0:3]])
Clean('lib', ['build_%s' % d for d in subdirs[0:3]])

# Provide an arch-specific install alias.  Basically, install everything
# that goes under the arch-specific install prefix.
# env.Alias(arch + '_install', [ '$PREFIX' ])
env.Alias('install', [ '$PREFIX' ])

# Don't want to do a Clean of $PREFIX here, in case there is
# other stuff there from other packages: we won't own $PREFIX.
# We can nuke $PREFIX/include/nidas, but don't do a global
# Clean of $PREFIX/bin and lib.  Also we don't assume we
# own $PREFIX/linux, but do own $PREFIX/rtlinux.
# env.Clean(arch + '_install','$PREFIX/include/nidas')
env.Clean('install','$PREFIX/include/nidas')
