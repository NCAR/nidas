# -*- python -*-

##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

##
##  Import the build environment.
##
Import('env')
arch = env['ARCH']

if arch == 'x86':
    env.AppendUnique(RPATH = [env.subst('$PREFIX/lib')] )

# Use the OTHER_ prefix only if it exists and is different than PREFIX
if env.has_key('OTHER_PREFIX') and env['PREFIX'] != env['OTHER_PREFIX']:
    import os
    other_include = env.subst("$OTHER_PREFIX/include")
    other_lib = env.subst("$OTHER_PREFIX/lib")
    if os.path.exists(other_include):
        env.AppendUnique(CPPPATH = [ other_include ])
    if os.path.exists(other_lib):
        env.AppendUnique(LIBPATH = [ other_lib ])
        if arch == 'x86':
            env.AppendUnique(RPATH = [other_lib] )

# Export all dynamic symbols in the executables, so that libraries
# loaded with dlopen() can resolve symbols already in the executable.
#
env.AppendUnique(LINKFLAGS = ['-rdynamic'])

##
## Specify RPATH to avoid the need for LD_LIBRARY_PATH later 
##
# Note that the addition of "build_core" to LIBPATH actually causes the
# addition of FOUR -L options to the linker commands.  It appears scons
# parses the name in multiple places, recognizes it as a build directory,
# then adds a -L argument for every combination of build and source
# directories with build_core in it.  Maybe it's a bug in scons, or some
# deep mystery.  Anyway, this is avoided by putting a directory node for
# build_core in the path instead of a string.
#
# dynld is needed on the path to link to libnidas_dynld.so.  Without it,
# scons will install dynld first so it can be linked into dependencies
# through the install path, which also means scons will remove the
# installed copy with the -c option, which is not usually what one wants
# from a clean.
#
env.PrependUnique(LIBPATH = [env.Dir("build_dynld")])
env.PrependUnique(LIBPATH = [env.Dir("build_core")])
env.PrependUnique(LIBPATH = [env.Dir("build_util")])

subdirs=Split("""util core dynld apps linux rtlinux""")

for dir in subdirs:
    SConscript('%s/SConscript' % dir,
               build_dir='build_%s' % dir,
               duplicate=0,exports={'env':env})

##
## ARCH target for creating modules, library, and executables
##

Alias(arch, ['build_%s' % dir for dir in subdirs])
Alias('lib', ['build_%s' % d for d in subdirs[0:3]])
Clean('lib', ['build_%s' % d for d in subdirs[0:3]])

# Provide an arch-specific install alias.  Basically, install everything
# that goes under the arch-specific install prefix.
env.Alias(arch + '_install', [ '$PREFIX' ])

# Don't want to do a Clean of $PREFIX here, in case there is
# other stuff there from other packages: we won't own $PREFIX.
# We can nuke $PREFIX/include/nidas, but don't do a global
# Clean of $PREFIX/bin and lib.  Also we don't assume we
# own $PREFIX/linux, but do own $PREFIX/rtlinux.
env.Clean(arch + '_install','$PREFIX/include/nidas')
