# -*- python -*-

##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

##
##  Import the build environment.
##
Import('env')
arch = env['ARCH']

# Use the OTHER_ prefix only if it exists and is different than PREFIX
if env.has_key('OTHER_PREFIX') and env['PREFIX'] != env['OTHER_PREFIX']:
    import os
    other_include = env.subst("$OTHER_PREFIX/include")
    other_lib = env.subst("$OTHER_PREFIX/lib")
    if os.path.exists(other_include):
        env.AppendUnique(CPPPATH = [ other_include ])
    if os.path.exists(other_lib):
        env.AppendUnique(LIBPATH = [ other_lib ])

# -rdynamic: Export all dynamic symbols in the executables, so that libraries
# loaded with dlopen() can resolve symbols already in the executable.
# See "man dlopen" for more info.
env.AppendUnique(LINKFLAGS=['-rdynamic'])

#############################################################################
# These comments apply to the arm-linux-ld and armbe-linux-ld that we are using,
# version 2.16.1.  Versions of ld for x86 in EL5 and Fedora are able to find
# libnidas with a -Ldir when linking against libnidas_dynld.so, and do not
# need the -rpath-link option. But we'll leave it in anyhow for x86.
#
# When ld is resolving these internal dependencies between
# shared libraries it does not search the -Ldir (LIBPATH) directories.
# Instead it searches these paths: -rpath-link, -rpath, $LD_RUN_PATH,
# $LD_LIBRARY_PATH, $DT_RUN_PATH,$DT_RPATH,/lib,/usr/lib and ld.so.conf.
# See man ld, under -rpath-link.
#
# Hence these -rpath-link options to search the build directories
# at link time.  Note that the run-time linker does not use
# -rpath-link, it uses -rpath
#
# Here's an example of the error that occurs when linking an executable
# program from nidas/apps:
# /opt/arcom/lib/gcc/arm-linux/3.4.4/../../../../arm-linux/bin/ld:
# warning: libnidas.so, needed by build_arm/build_dynld/libnidas_dynld.so, not found (try using -rpath or -rpath-link)
#############################################################################
#
env.Append(LINKFLAGS=
    ['-Xlinker','-rpath-link=' + env.Dir('build_util').path + ':' + env.Dir('build_core').path])

# Initialize LIBPATH to empty list so
# that env['LIBPATH'] doesn't fail in SConscripts
env.Append(LIBPATH = []);

# To decipher the link statement:
# print 'LINKCOM=' + str(env['LINKCOM'])
# print '_LIBDIRFLAGS=' + str(env['_LIBDIRFLAGS'])
# print '_LIBFLAGS=' + str(env['_LIBFLAGS'])

# Check for headers and libraries
conf = Configure(env)
if conf.CheckCHeader('sys/capability.h'):
    conf.env.Append(CPPDEFINES = ['HAS_CAPABILITY_H'])
if conf.CheckLib('cap'):
    conf.env.AppendUnique(LIBS = 'cap')

if conf.CheckCHeader('sys/inotify.h'):
    conf.env.Append(CPPDEFINES = ['HAS_INOTIFY_H'])

# Plans are for bzlib to be a pre-requisite for NIDAS. Until
# it is on all our systems, we'll check for it.
if conf.CheckCHeader('bzlib.h'):
    conf.env.Append(CPPDEFINES = ['HAS_BZLIB_H'])

if conf.CheckCHeader(['sys/socket.h','bluetooth/bluetooth.h','bluetooth/rfcomm.h'],"<>"):
    conf.env.Append(CPPDEFINES = ['HAS_BLUETOOTHRFCOMM_H'])

# Check for nc_server header and library on /opt/nc_server
libpath = env['LIBPATH']

# arch-dependent library path
if (arch == 'x86'):
    nclibpath = '/opt/nc_server/lib'
else:
    nclibpath =  '/opt/nc_server/' + arch + '/lib'

env.Append(LIBPATH=[nclibpath])

if conf.CheckLibWithHeader('nc_server_rpc',
    '/opt/nc_server/include/nc_server_rpc.h','C++',
    'xdr_connection(0,0);',autoadd=1):
    conf.env.Append(
        CPPDEFINES = ['HAS_NC_SERVER_RPC_H'],
        CPPPATH=['/opt/nc_server/include'],
        LIBS=['nc_server_rpc'])
else:
    conf.env.Replace(LIBPATH=[libpath])

env = conf.Finish()

# print ["LIBPATH=%s" % p for p in env['LIBPATH']]

subdirs=Split("""util core dynld apps linux""")

for dir in subdirs:
    SConscript('%s/SConscript' % dir,
               variant_dir='build_%s' % dir,
               duplicate=0,exports={'env':env})

##
## ARCH target for creating modules, library, and executables
##

Alias(arch, ['build_%s' % dir for dir in subdirs])
Alias('lib', ['build_%s' % d for d in subdirs[0:3]])
Clean('lib', ['build_%s' % d for d in subdirs[0:3]])

# Provide an arch-specific install alias.  Basically, install everything
# that goes under the arch-specific install prefix.
# env.Alias(arch + '_install', [ '$PREFIX' ])
env.Alias('install', [ '$PREFIX' ])

# Don't want to do a Clean of $PREFIX here, in case there is
# other stuff there from other packages: we won't own $PREFIX.
# We can nuke $PREFIX/include/nidas, but don't do a global
# Clean of $PREFIX/bin and lib.  Also we don't assume we
# own $PREFIX/linux.
# env.Clean(arch + '_install','$PREFIX/include/nidas')
env.Clean('install','$PREFIX/include/nidas')
