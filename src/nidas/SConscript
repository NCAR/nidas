# -*- python -*-
## 2006, Copyright University Corporation for Atmospheric Research

import os
import subprocess as sp
from SCons.Script import Environment, Import, SConscript, Export

Import('env')
env: Environment

# -rdynamic: Export all dynamic symbols in the executables, so that libraries
# loaded with dlopen() can resolve symbols already in the executable.
# See "man dlopen" for more info.
env.AppendUnique(LINKFLAGS=['-rdynamic'])

installs = []
installs += env.Install('$PREFIX/include/nidas', 'include/nidas/Config.h')

# Build Revision.h from git describe.  This does not depend on the target,
# only the source repo, so it is not installed in the variant dir but in the
# source tree, where it can be included easily in source archives.
env.Tool('gitinfo')
info = env.GitInfo("#/nidas/Revision.h", "#/nidas")
installs += env.Install('$PREFIX/include/nidas', info)

env.PrependUnique(CPPPATH=['$VARIANT_DIR/include'])

subdirs = env.Split("""util core dynld apps scripts linux""")

for dir in subdirs:
    SConscript('%s/SConscript' % (dir), exports=['env'])

env.Alias('lib', subdirs[0:3])

installs += ['${INSTALL_ROOT}$PREFIX/include',
             '${INSTALL_ROOT}$PREFIX/$ARCHLIBDIR']

env.Alias('install', installs)

def dpkg_arch(name):
    try:
        return sp.check_output(["dpkg-architecture", "-q", name],
                               universal_newlines=True).strip()
    except sp.CalledProcessError:
        return None

# this needs to be moved into a tool at some point
ldconfname = 'nidas.conf'
osid = env.get('VARIANT_OS', '')
debian = (osid.startswith('debian') or osid.startswith('raspbian') or
          osid.startswith('ubuntu'))
multiarch = None
if debian:
    # On Debian systems, need to figure out the right suffix to the nidas conf
    # file for ld.so.conf.d.  DEB_HOST_MULTIARCH takes precedence over
    # DEB_HOST_GNU_TYPE, and an environment setting takes precedence over
    # querying dpkg-architecture.
    multiarch = os.environ.get('DEB_HOST_MULTIARCH')
    multiarch = multiarch or os.environ.get('DEB_HOST_GNU_TYPE')
    multiarch = multiarch or dpkg_arch("DEB_HOST_MULTIARCH")
    multiarch = multiarch or dpkg_arch("DEB_HOST_GNU_TYPE")
if debian and multiarch:
    ldconfname = 'nidas-%s.conf' % (multiarch)
    env.PrintProgress(f'debian={debian}, multiarch={multiarch}: '
                      f"nidas ld.so conf file: {ldconfname}")

ldc = env.Substfile(ldconfname, 'nidas.conf.in')
etcldc = env.Install('${SYSCONFIGDIR}/ld.so.conf.d', ldc)
env.Alias('install.root', etcldc)

# Build nidas.pc.  This substitutes PREFIX as the intended installation
# location, even if everything is being installed under INSTALL_ROOT.  It gets
# installed two places: the nidas lib directory and the system pkg-config
# directory, using two separate aliases, install and install.root.
env['SUBST_DICT'] = {
    '@PREFIX@': '$PREFIX',
    '@ARCHLIBDIR@': '$ARCHLIBDIR',
    '@REPO_TAG@': '$REPO_TAG'
}
pc = env.Substfile('nidas.pc.in')
env.Alias('install', env.Install('$PREFIX/$ARCHLIBDIR/pkgconfig', pc))
env.Alias('install.root', env.Install('${PKGCONFIGDIR}', pc))
