# -*- python -*-

##  Copyright 2005,2006 UCAR, NCAR, All Rights Reserved

##
##  Import the build environment.
##
Import('env')
arch = env['ARCH']

env.AppendUnique(CPPPATH = [env.subst("$PREFIX/include")] )
env.AppendUnique(LIBPATH = [env.subst("$PREFIX/lib")] )

# Use the OTHER_ prefix only if it exists and is different than PREFIX
if env.has_key('OTHER_PREFIX') and env['PREFIX'] != env['OTHER_PREFIX']:
    import os
    other_include = env.subst("$OTHER_PREFIX/include")
    other_lib = env.subst("$OTHER_PREFIX/lib")
    if os.path.exists(other_include):
        env.AppendUnique(CPPPATH = [ other_include ])
    if os.path.exists(other_lib):
        env.AppendUnique(LIBPATH = [ other_lib ])

# Export all dynamic symbols in the executables, so that libraries
# loaded with dlopen() can resolve symbols already in the executable.
#
env.AppendUnique(LINKFLAGS = ['-rdynamic'])

##
## Specify RPATH to avoid the need for LD_LIBRARY_PATH later 
##
# Note that the addition of "build_core" to LIBPATH actually causes the
# addition of FOUR -L options to the linker commands.  It appears scons
# parses the name in multiple places, recognizes it as a build directory,
# then adds a -L argument for every combination of build and source
# directories with build_core in it.  Maybe it's a bug in scons, or some
# deep mystery.  Anyway, this is avoided by putting a directory node for
# build_core in the path instead of a string.
#
# dynld is needed on the path to link to libnidas_dynld.so.  Without it,
# scons will install dynld first so it can be linked into dependencies
# through the install path, which also means scons will remove the
# installed copy with the -c option, which is not usually what one wants
# from a clean.
#
env.PrependUnique(LIBPATH = [env.Dir("build_dynld")])
env.PrependUnique(LIBPATH = [env.Dir("build_core")])
if arch != 'arm':
    env.PrependUnique(RPATH = [env.Dir("build_dynld").get_abspath()])
    env.PrependUnique(RPATH = [env.Dir("build_core").get_abspath()])

subdirs=Split("""util core dynld apps linux""")
defaultdirs=subdirs[1:]
libdirs=subdirs[1:3]

# No point in building or installing rtlinux except for arm builds.
if arch == 'arm':
    subdirs += Split("""rtlinux""")

##
## ARCH target for creating modules, library, and executables
##
env.Alias(arch, ['build_%s' % dir for dir in defaultdirs])
Alias('lib', ['build_%s' % d for d in libdirs])

# Provide an arch-specific install alias.  Basically, install everything
# that goes under the arch-specific install prefix.
archinstall= env.Alias(arch+'_install', [ '$PREFIX' ])

for dir in subdirs:
    SConscript('%s/SConscript' % dir,
               build_dir='build_%s' % dir,
               duplicate=0,exports={'env':env})

Default([ "build_%s" % dir for dir in defaultdirs ])
