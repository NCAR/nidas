# -*- python -*-
## 2006, Copyright University Corporation for Atmospheric Research

from SCons.Script import Environment, Import, SConscript, Export

Import('env')
env: Environment

arch = env['ARCH']  # empty string for native builds

# Use the OTHER_ prefix only if it exists and is different than PREFIX
if env.get('OTHER_PREFIX'):
    import os
    other_include = env.subst("$OTHER_PREFIX/include")
    other_lib = env.subst("$OTHER_PREFIX/lib")
    if os.path.exists(other_include):
        print("Adding OTHER_PREFIX %s to CPPPATH." % (other_include))
        env.AppendUnique(CPPPATH = [ other_include ])
    if os.path.exists(other_lib):
        print("Adding OTHER_PREFIX %s to LIBPATH." % (other_lib))
        env.AppendUnique(LIBPATH = [ other_lib ])

# -rdynamic: Export all dynamic symbols in the executables, so that libraries
# loaded with dlopen() can resolve symbols already in the executable.
# See "man dlopen" for more info.
env.AppendUnique(LINKFLAGS=['-rdynamic'])

# Create a node for the Config.h file, so all Configure contexts for this
# variant append their settings to this exact file under the variant dir.
configh = env.File("include/nidas/Config.h")

def NidasConfigure(env):
    """
    Return a Configure context whose settings will be appended to a single
    global config header file.  This does not create a temporary environment,
    since the settings and build flags for all the config checks are meant to
    be added to the given environment.  SConscripts only need to use this if
    the configure settings need to be added to Config.h.  However, all
    SConscript files have to be careful to put the configure files under
    VARIANT_DIR, so configuration for different variants is cached separately.
    """
    conf = env.Configure(conf_dir="$VARIANT_DIR/.sconf_temp",
                         log_file='$VARIANT_DIR/config.log',
                         config_h=configh)
    return conf

def nidasconfig(env):
    env.AddMethod(NidasConfigure)

# All the configure checks that were here have been moved to the SConscript
# files where the dependencies are needed.  For example, all the lower-level
# system header checks are in util. Instead, the nidasconfig tool can be
# applied to get the NidasConfigureContext method added.
Export('nidasconfig')

installs = []
installs += env.Install('$ARCHPREFIX/include/nidas','include/nidas/Config.h')

# Update Revision.h from git describe
info = env.GitInfo("include/nidas/Revision.h", "#/nidas")
installs += env.Install('$ARCHPREFIX/include/nidas', info)

# When duplicate=0, the variant_dir of this SConscript, 
# ("build","build_arm" or "build_armbe") is not duplicated using
# symbolic or hard links from the source dir, "nidas".
# Instead scons puts the two paths in the compile runstring where
# appropriate, including possibly duplicating items in the CPPPATH
# to search for headers in both the variant_dir and the source dir.
# If you specify CPPPATH="include", scons adds the successive
# SConscript dirs to the path, and creates two -I options in the compiles:
#   -Ibuild/core/include and -Inidas/core/include

# This hack using Dir() results in the CPPPATH not being duplicated
# in the compile and successive variant_dirs not being added:
#   -Ibuild/include
env.PrependUnique(CPPPATH = ['#', Dir('.').Dir('include')])

subdirs = env.Split("""util core dynld apps linux""")

for dir in subdirs:
    SConscript('%s/SConscript' % (dir), exports=['env'])

env.Alias('lib', subdirs[0:3])

installs += ['$ARCHPREFIX/include', '$ARCHPREFIX/$ARCHLIBDIR']

env.Alias('install', installs)
