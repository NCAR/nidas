# -*- python -*-
## 2006, Copyright University Corporation for Atmospheric Research

import os

##
##  Import the build environment.
##
Import('env')
env = env.Clone()
arch = env['ARCH']  # empty string for native builds
targetArch=arch
if targetArch == "":
    targetArch="host"

# env.AppendUnique(CXXFLAGS = Split("""
# """))

##
##  List of headers files
##
headers = [ Split("""
    auto_ptr.h
    BitArray.h
    BluetoothAddress.h
    BluetoothRFCommSocket.h
    BluetoothRFCommSocketAddress.h
    Bzip2FileSet.h
    DatagramPacket.h
    DSMPowerCtrl.h
    DSMSwitchCtrl.h
    EndianConverter.h
    EOFException.h
    EPoll.h
    Exception.h
    FileSet.h
    FtdiHW.h
    GpioIF.h
    Inet4Address.h
    Inet4NetworkInterface.h
    Inet4PacketInfo.h
    Inet4SocketAddress.h
    InterruptedException.h
    InvalidParameterException.h
    IOException.h
    IOTimeoutException.h
    IoPollerIf.h
    IoPollerAbs.h
    Logger.h
    McSocket.h
    MutexCount.h
    ParseException.h
    PowerCtrlIf.h
    PowerCtrlAbs.h
    FtdiDSMPowerCtrl.h
    FtdiDSMPowerGPIO.h
    FtdiSensorPowerCtrl.h
    FtdiSwitchGPIO.h
    IoPoller.h
    PPoll.h
    Process.h
    ptytools.h
    SPoll.h
    SensorPowerCtrl.h
    SerialOptions.h
    SerialPort.h
    SocketAddress.h
    Socket.h
    SysfsGpio.h
    SysfsDSMPowerCtrl.h
    SysfsSensorPowerCtrl.h
    Termios.h
    Thread.h
    ThreadSupport.h
    time_constants.h
    UnixSocketAddress.h
    UnknownHostException.h
    UTime.h
    util.h
    FtdiXcvrGPIO.h
    """)
]
# print(["headers="] + [str(h) for h in headers])

sources = [ Split("""
    BitArray.cc
    BluetoothAddress.cc
    BluetoothRFCommSocket.cc
    BluetoothRFCommSocketAddress.cc
    Bzip2FileSet.cc
    DSMPowerCtrl.cc
    EndianConverter.cc
    EPoll.cc
    Exception.cc
    FileSet.cc
    FtdiHW.cc
    FtdiDSMPowerCtrl.cc
    FtdiSensorPowerCtrl.cc
    GpioIF.cc
    Inet4Address.cc
    Inet4NetworkInterface.cc
    Inet4SocketAddress.cc
    IoPoller.cc
    Logger.cc
    McSocket.cc
    PPoll.cc
    PowerCtrlAbs.cc
    PowerCtrlIf.cc
    Process.cc
    ptytools.cc
    SPoll.cc
    SensorPowerCtrl.cc
    SerialOptions.cc
    SerialPort.cc
    Socket.cc
    SysfsGpio.cc
    SysfsDSMPowerCtrl.cc
    SysfsSensorPowerCtrl.cc
    Termios.cc
    Thread.cc
    ThreadSupport.cc
    UnixSocketAddress.cc
    UTime.cc
    util.cc
    """)
]

##
##  Build the libnidas_util library.
##
conf = Configure(env)
if conf.CheckLib('cap'):
    conf.env.AppendUnique(LIBS = 'cap')
if conf.CheckLib('bz2'):
    conf.env.AppendUnique(LIBS = 'bz2')
if conf.CheckLib('bluetooth'):
    conf.env.AppendUnique(LIBS = 'bluetooth')
env = conf.Finish()

def libusb1(env):
    # There may be a way to check and set both header and library in the
    # environment using Configure(), but I haven't checked...
    cfenv = env.Clone()
    cfenv.Replace(LIBS=[])
    conf = Configure(cfenv)
    conf.CheckLib('usb-1.0')
    cfenv = conf.Finish()
    env.Append(LIBS=cfenv.get('LIBS', []))
    # Fedora installs header into a subdirectory.
    usbpath = env.Dir("/usr/include/libusb-1.0").abspath
    if os.path.exists(usbpath):
        env.Append(CPPPATH=[usbpath])

def libftdi(env):
    # Force link libftdi.a.  Prepend rel path w/# to escape the confines of
    # scons root directory w/SConstruct.
    #libftdi = File('#../../libftdi/libftdi1-1.4/build-' + targetArch +
    #               '/src/libftdi1.a')
    cfenv = env.Clone()
    cfenv.Replace(LIBS=[])
    conf = Configure(cfenv)
    conf.CheckLib('ftdi1')
    cfenv = conf.Finish()
    env.Append(LIBS=cfenv.get('LIBS', []))
    # On Fedora, libftdi-devel installs headers under /usr/include/libftdi1.
    hdir = env.Dir("/usr/include/libftdi1").abspath
    if os.path.exists(hdir):
        env.Append(CPPPATH=[hdir])
    env.Require([libusb1])

# Required to build nidas_util
deps = [libftdi, 'boost_system', 'boost_filesystem', 'boost_regex']
env.Require(deps)
env.Append(LIBS=['pthread'])
arch = env['ARCH']

objects = env.SharedObject(sources)

# build libnidas_util.so
lib = env.SharedLibrary3('nidas_util', objects)
libnidas_util = lib[0]

# Test SConscripts need the full path to the library to set LD_LIBRARY_PATH
Export({'LIBNIDAS_UTIL' + arch: lib[0]})

slib = env.StaticLibrary('nidas_util', objects)

##
## Install targets for libraries and headers.
##
nodes = []
nodes += env.SharedLibrary3Install('$ARCHPREFIX', lib)
nodes += env.Install('$ARCHPREFIX/$ARCHLIBDIR', slib)
nodes += env.Install('$ARCHPREFIX/include/nidas/util', headers)

# Build nidas.pc from the top level. It is done here since we know
# ARCHLIBDIR and REPO_TAG
env.Command('nidas.pc', '#nidas.pc.in',
            "sed -e 's,@PREFIX@,$ARCHPREFIX,' "
            "-e 's,@ARCHLIBDIR@,$ARCHLIBDIR,' "
            "-e 's,@REPO_TAG@,$REPO_TAG,' < $SOURCE > $TARGET")

Alias('install', env.Install('$ARCHPREFIX/$ARCHLIBDIR/pkgconfig', 'nidas.pc'))

Alias('install', nodes)
env.Clean('install', nodes)

def nidasutil(env):
    "SCons tool to setup environment to build against libnidas_util."
    env.Append(LIBS=libnidas_util)
    env.Require(deps)
    env.Append(LIBS=['pthread'])

Export("nidasutil")
