# -*- python -*-
## 2006, Copyright University Corporation for Atmospheric Research

import eol_scons.parseconfig as pc

##
##  Import the build environment.
##
Import('env')
env = env.Clone(tools = ['nidas'])
arch = env['ARCH']  # empty string for native builds

# -ggdb
# -DXML_DEBUG
# env.AppendUnique(CXXFLAGS = Split("""
# """))

SConscript(dirs = ["raf", "isff", "iss"], exports={'env':env})

headers = Split("""
    A2DSensor.h
    AsciiOutput.h
    Bzip2FileSet.h
    ChronyLog.h
    DSC_A2DSensor.h
    DSC_AnalogOut.h
    DSC_Event.h
    DSC_FreqCounter.h
    DSC_PulseCounter.h
    DSMSerialSensor.h
    FileSet.h
    GPS_NMEA_Serial.h
    GPS_Novatel_Serial.h
    IEEE_Float.h
    IR104_Relays.h
    ModbusRTU.h
    ParoSci_202BG_Calibration.h
    ParoSci_202BG_P.h
    ParoSci_202BG_T.h
    RawSampleInputStream.h
    RawSampleOutputStream.h
    RawSampleService.h
    SampleArchiver.h
    SampleInputStream.h
    SampleOutputStream.h
    SampleProcessor.h
    StatisticsCruncher.h
    StatisticsProcessor.h
    TSI_CPC3772.h
    UDPSampleOutput.h
    UDPSocketSensor.h
    Uio48Sensor.h
    ViperDIO.h
    WatchedFileSensor.h
    WxtSensor.h
    XMLConfigAllService.h
    XMLConfigService.h
""")

##
##  source files in libnidas_dynld
##
sources = Split("""
    A2DSensor.cc
    AsciiOutput.cc
    Bzip2FileSet.cc
    ChronyLog.cc
    DSC_A2DSensor.cc
    DSC_AnalogOut.cc
    DSC_Event.cc
    DSC_FreqCounter.cc
    DSC_PulseCounter.cc
    DSMSerialSensor.cc
    FileSet.cc
    GPS_NMEA_Serial.cc
    GPS_Novatel_Serial.cc
    IEEE_Float.cc
    IR104_Relays.cc
    ModbusRTU.cc
    ParoSci_202BG_Calibration.cc
    ParoSci_202BG_P.cc
    ParoSci_202BG_T.cc
    RawSampleInputStream.cc
    RawSampleOutputStream.cc
    RawSampleService.cc
    SampleArchiver.cc
    SampleInputStream.cc
    SampleOutputStream.cc
    SampleProcessor.cc
    StatisticsCruncher.cc
    StatisticsProcessor.cc
    TSI_CPC3772.cc
    UDPSampleOutput.cc
    UDPSocketSensor.cc
    Uio48Sensor.cc
    ViperDIO.cc
    WatchedFileSensor.cc
    WxtSensor.cc
    XMLConfigAllService.cc
    XMLConfigService.cc
""")

if arch == 'arm':
    archsources=Split("""
    """)
    archheaders=Split("""
    """)
else:
    archsources=Split("""
    """)
    archheaders=Split("""
    """)

env.Tool('nidasconfig')
conf = env.NidasConfigure()

# It seems like for cross-builds the PKG_CONFIG_PATH needs to be adjusted
# accordingly, or maybe the path to pkg-config needs to be set, such as
# /opt/arcom/bin/armbe-linux-pkg-config.  However, the closest thing to
# this I've found is in scripts/build_nidas.sh.  Maybe that kind of
# customization should be in the scons arm*cross tools.
pc.ParseConfig(conf.env, 'pkg-config --cflags --libs nc_server')
conf.CheckLib('nc_server_rpc')
conf.CheckLibWithHeader('nc_server_rpc', 'nc_server_rpc.h','C++',
                        'xdr_connection(0,0);')
# The nc_server build flags and library are added to the build environment
# without the RPATH=conf.env['LIBPATH'] setting.  Both RedHat and Debian
# advise against it, and an rpmbuild now fails in Fedora 35.

pc.ParseConfig(conf.env, 'pkg-config --libs gsl')
conf.CheckCXXHeader('gsl/gsl_linalg.h')
conf.CheckLibWithHeader('gsl', 'gsl/gsl_linalg.h','C',
                        'gsl_linalg_LU_solve(0,0,0,0);')

conf.CheckCHeader('sys/inotify.h')

# uio48.h is a header file with ioctl definitions for a UIO48
# digital I/O chip, as found on a PCM-C418 Vortex.
have_uio48 = False
if conf.CheckCHeader('uio48.h'):
    have_uio48 = True

conf.CheckLib('modbus')
env = conf.Finish()

# Provide a tool function which apps SConscript can use to check if UIO48 is
# enabled.
def uio48(env):
    env["HAVE_UIO48"] = have_uio48

Export('uio48')

##
##  Build the nidas_dynld library.
##
env.Append (LIBNIDAS_DYNLD_SOURCES = 
            [ env.File(f) for f in sources + archsources ])

# build libnidas_dynld.so
lib = env.SharedLibrary3('nidas_dynld' , env['LIBNIDAS_DYNLD_SOURCES'],
                         LIBS=['nidas'] + env['LIBS'])

# Export the locally built library 
Export({'LIBNIDAS_DYNLD' + arch: lib[0]})

##
## Install targets for library and headers.
##
nodes = []
nodes += env.SharedLibrary3Install('$ARCHPREFIX',lib)
nodes += env.Install('$ARCHPREFIX/include/nidas/dynld',headers + archheaders)

Alias('install',nodes)
Clean('install',nodes)

def nidasdynld(xenv):
    "Tool to apply dynld link settings to an environemnt."
    # Eventually this would be the place to add the dynld library itself to
    # the link command, but for the moment only apps/SConscript uses this, and
    # the dynld library is already added by the NidasProgram() pseudo-builder.
    #
    # xenv.AppendUnique(LIBS=['nidas_dynld'])
    xenv.AppendUnique(LIBS=env.get('LIBS', []))
    xenv.AppendUnique(LIBPATH=env.get('LIBPATH', []))
    # CPPPATH needed also for nc_server includes
    xenv.AppendUnique(CPPPATH=env.get('CPPPATH', []))

Export('nidasdynld')
