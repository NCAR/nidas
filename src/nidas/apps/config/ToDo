
0. validation
Site::validateVariables() [maclean]
DSMConfig::removeSensor() make public [done in branch; maclean in trunk]

Document::addSensor()
 add calls to:
   dsmConfig->getSite()->validateVariables()  [done in branch; maclean in trunk]

Branch changes for DSMConfig::DeviceUnique [done in branch; maclean in trunk]

for maclean:
 Multiple sites can have same attributes.  When parsing if we have same site name, class, number and suffix then
   abandon all hope ye who enter.
   -  Consider change of nidas to require some sort of uniqueness check on name? name and class?
   - xml requires name,class and optional number,suffix ; nidas code does no checks

for maclean:
 do something about this bit from configwindow.cc
            // XXX *** XXX
            // very bad casting of const to non-const to get a mutable pointer to our dsm
            // *** NEEDS TO BE FIXED either here or in nidas::core
            //
            DSMConfig * dsm = (DSMConfig*)(di.next());
 => Site::getDSMConfigIterator() returns a const iterator and is only way to get an individual DSMConfig,
    which we need non-const to later add/delete/edit sensors etc

1. investigate Qt's model/view business for table displays
   ProjectQModel
   QTreeView
     "node"(Project->Site->DSM->(SensorType->)XXXsensor->sample->variable),class(dotted),id,ID/REF,long/device-name
   TabbedTablesQView
     ttqv->setSelection(tree->getSelection())

1.1 full code review for efficiency, memory leaks, separation of concerns
       get business model and logic out of configWindow as much as possible;
       configWindow should just know about Qt windows & apps

2. What about Fast2DC device?  /dev/usbtwod_64_ or /dev/usbtwod
   - or more generally, a sensor that doesn't have a simple mapping?

3.  What about sensors that don't appear in our current map?  Default? or warn user and tell them to   
    get help?  Or give a chance to type free text and provide range?
    - increase <sensorCatalog> to all-known sensors?
    - get a sensorCatalog from elsewhere (another config file?)?
    - templates for c130,gv,...

4. Investigate efficiencies of DSMDisplayWidget::getDSMNode - better way to find site and dsm?
   - Can nidas fromDOMs insert pointers to itself into the DOM tree using setUserData?

5. demo bits:
add sensor dialog : sensor-based labels/constraints
sample rate: drop down 10/100/500
for beta: add dsm, specify var name, add analog vars

99. notes

for editing, consider:

 find the DOMNode/DOMElement to be edited
 DOMNode::cloneNode(true) to get a full recursive copy
 edit the copy
 validate xml somehow
   if bad, quit/error
 find nidas object
 remove it from parent (so it doesn't interfere with fromDOM/validation)
 to get a new nidas object
   use nidas parent CHILDTYPEfromDOMElement()
   (or maybe the CHILDTYPE's own fromDOM)
 perform any extra nidas validation logic
 if new nidas is good (no exceptions) then
   add it to parent
   delete old nidas obj
   add new DOMNode into DOM (if not already there from validation)
   (recursively) delete old DOMNode
 else
   delete new nidas obj
   delete new DOMNode
   quit/error




999. feb02
 attempt a basic QHeaderView to play with / try to resolve tree/table header funniness
   FAIL QHeaderView are just QAbstractItemView's tied to the same model,
        using model's headerDataChanged signal and reading the header data
        from model's same headerData()
        -tried changing header views during setRootIndex() but with the same
         model, this was fruitless; introducing a new model was futile chasing
         of rabbits down holes through the Qt-glass
    idea: change model to have all possible nidas attributes as columns
       and hide/show headerView (and TableView) columns based on place in model
       - makes for a less "realistic" model


 wire add/delete sensor into new model/views

