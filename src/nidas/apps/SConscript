# -*- python -*-

##  Copyright 2005 UCAR, NCAR, All Rights Reserved

##
##  Import the cross-build environment.
##
import os

Import('env')
arch = env['ARCH']

# print 'LIBS=' + str(env['LIBS'])
#

# complete set of LIBS and LIBPATH
alllibs=['nidas_util','nidas','nidas_dynld',env['LIBS'],'xerces-c','xmlrpcpp',]
libpath=[env.Dir('../build_util'),env.Dir('../build_core'),env.Dir('../build_dynld'),env['LIBPATH']]

if arch == 'arm':
    archapps=Split("""
        viper_dio.cc
    """)

else:
    if arch == 'x86':
        # Qt targets, built and run only on x86
        #
        # Temporary hack. Existing builds created the auto_cal executable,
        # and this SConscript would fail, expecting auto_cal to be a directory.
        # This happened even when I used a variant_dir="auto_cal_dir" arg.
        # Another scons mystery.
        autocal = env.Dir('.').abspath + '/auto_cal'
        # print "autocal=" + autocal
        if os.path.isfile(autocal):
            # print "autocal is file=" + autocal
            os.popen('rm -f '+ autocal)
        acenv = env.Clone(LIBS = alllibs, LIBPATH = libpath)
#       acenv.SConscript("auto_cal/SConscript", exports={'env':acenv})

    archapps=Split("""
    """)

    # ck_arinc.cc
    # sample_test.cc
    # psi9116_sim.cc
    # ck_a2d.cc
    # raf/cvi_lv_test_in.cc
    # raf/cvi_lv_test_out.cc
    # ck_lams.cc
apps = Split("""
    nidas_udp_relay.cc
    lidar_vel.cc
    ck_aout.cc
    ck_calfile.cc
    extract2d.cc
    ir104.cc
    merge_verify.cc
    nidsmerge.cc
    dsm_server.cc
    dsm.cc
    statsproc.cc
    sensor_sim.cc
    sing.cc
    data_stats.cc
    data_dump.cc
    dmd_mmat_test.cc
    sync_dump.cc
    sync_server.cc
    status_listener.cc
    rserial.cc
    ck_xml.cc
    isff/ck_goes.cc
    isff/pdecode.cc
    isff/prep.cc
    xml_dump.cc
    proj_configs.cc
    n_hdr_util.cc
    sensor_extract.cc
""")

# apps which don't need, or want, the nidas libraries
# These are also only needed on arm/armbe
nlapps_embed = Split("""
    set_pcmcom8.c
    isff/set_emerald.c
    isff/emerald_dio.cc
""")

# apps which just need the nidas_util library
# move sing here (it still needs nidas::core::Looper)
nuapps_embed = Split("""
    gps_nmea_sysclock.cc
    garmin.cc
""")

# apps which just need the nidas_util library
# move sing here (it still needs nidas::core::Looper)
nuapps = Split("""
    tee_tty.cc
    utime.cc
""")

# Note that we don't have to search the pthread, dl, xerces-c, cap, etc
# libraries, since they were searched when libnidas_dynld was built.
nodes = []
# libs = [env['LIBNIDAS_DYNLD'], env['LIBNIDAS'], env['LIBNIDAS_UTIL']]
for i in apps + archapps:
    node = env.Program( source=i,LIBS=alllibs,LIBPATH=libpath)
    nodes += node
    node = env.Install('$PREFIX/bin', node)
    # env.Depends(node, libs)

# suppress linking against nidas libraries
if arch != 'x86':
    for i in nlapps_embed:
        node = env.Program(source=i,LIBS=[])
        nodes += node
        node = env.Install('$PREFIX/bin', node)

for i in nuapps:
    node = env.Program(source=i,
                       LIBS= ['nidas_util','pthread'],LIBPATH=[env.Dir('../build_util')])
    nodes += node
    node = env.Install('$PREFIX/bin', node)
    # env.Depends(node, [env['LIBNIDAS_UTIL']])

# link against nidas_util
if arch != 'x86':
    for i in nuapps_embed:
        node = env.Program(source=i,
                           LIBS= ['nidas_util','pthread'],LIBPATH=[env.Dir('../build_util')])
        nodes += node
        node = env.Install('$PREFIX/bin', node)
        # env.Depends(node, [env['LIBNIDAS_UTIL']])

env['NIDAS_APPS'] = {}
for node in nodes:
    name = env.subst("${TARGET.filebase}", target=node)
    env['NIDAS_APPS'][name] = node
    # print 'name=' + name + ' node=' + env.subst("${TARGET.abspath}", target=node)

# env.Clean(arch + '_install', nodes)
env.Clean('install', nodes)
