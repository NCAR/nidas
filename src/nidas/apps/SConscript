# -*- python -*-

##  Copyright 2005 UCAR, NCAR, All Rights Reserved
#
##
##  Import and clone the cross-build environment.
##
Import('env')
env = env.Clone(tools = ['nidas'])
arch = env['ARCH']  # empty string for native builds
machs = env['MACHS']

# Specify the build for each executable, linking against a library only
# if necessary.
#
# For example, status_listener.cc is the only program below
# that directly references symbols in libxmlrpcpp.so, so only it needs
# xmlrpcpp in LIBS.  This actually has minimal effect, since libnidas.so
# references libxmlrpcpp.so, and so any executable linked against libnidas.so
# will require libxmlrpcpp.so.
#
# However, there are some executables, like set_pcmcom8, that are run
# early at boot time, for which we would like to minimize library dependencies.
#
# Also, programs like dsm and dsm_server, which dynamically load routines
# from nidas_dynld, don't need to be linked against it here. 
# By not specifying nidas_dynld in the LIBS list for those programs,
# we can test that dynamic loading is working without a library having
# to be pre-linked.
#
# So rather than having several lists of source files, and separate builds
# for each list, it seems more straightforward to specify the
# build for each executable, using the above function to reduce the verbage
# somewhat.

env.NidasProgram('arinc_out.cc')
env.NidasProgram('ck_aout.cc')
env.NidasProgram('ck_calfile.cc')
env.NidasProgram('ck_xml.cc')
env.NidasProgram('data_dump.cc')
env.NidasProgram('data_stats.cc')
env.NidasProgram('dmd_mmat_test.cc')
env.NidasProgram('dsm_server.cc')
env.NidasProgram('dsm.cc')
env.NidasProgram('extract2d.cc')
env.NidasProgram('ir104.cc')
env.NidasProgram('lidar_vel.cc')
env.NidasProgram('merge_verify.cc')
env.NidasProgram('nidas_udp_relay.cc')
env.NidasProgram('nidsmerge.cc')
env.NidasProgram('n_hdr_util.cc')
env.NidasProgram('proj_configs.cc')
env.NidasProgram('rserial.cc')
env.NidasProgram('sensor_extract.cc')
env.NidasProgram('sensor_sim.cc')
env.NidasProgram('statsproc.cc')
env.NidasProgram('status_listener.cc')
env.NidasProgram('sync_dump.cc')
env.NidasProgram('sync_server.cc')
env.NidasProgram('xml_dump.cc')
env.NidasProgram('isff/ck_goes.cc')
env.NidasProgram('isff/pdecode.cc')
env.NidasProgram('isff/prep.cc')

# Programs which only use libnidas_util.so, not libnidas.
env.NidasUtilProgram('sing.cc')
env.NidasUtilProgram('tee_tty.cc')
env.NidasUtilProgram('utime.cc')

if 'viper' in machs:
    # controls DIO pins on a Viper
    env.NidasProgram('viper_dio.cc')

if arch != '':
    # Programs which just do ioctls to NIDAS driver modules, and don't
    # otherwise use anything in the nidas libraries.
    env.NidasPlainProgram('set_pcmcom8.c')
    env.NidasPlainProgram('isff/set_emerald.c')
    env.NidasPlainProgram('isff/emerald_dio.cc')

    # nidas_util
    env.NidasUtilProgram('gps_nmea_sysclock.cc')
    env.NidasUtilProgram('garmin.cc')

# build auto_cal and config
SConscript("auto_cal/SConscript",
    variant_dir='build_auto_cal',duplicate=0,exports={'env':env})
SConscript("edit_cal/SConscript",
    variant_dir='build_edit_cal',duplicate=1,exports={'env':env})
SConscript("config/SConscript",
    variant_dir='build_config',duplicate=0,exports={'env':env})

