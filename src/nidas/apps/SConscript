# -*- python -*-

##  Copyright 2005 UCAR, NCAR, All Rights Reserved

##
##  Import the cross-build environment.
##
Import('env')
# env = env.Clone()
arch = env['ARCH']

# print 'LIBS=' + str(env['LIBS'])

if arch == 'arm':
    archapps=Split("""
        ck_dout.cc
    """)
else:
    archapps=Split("""
    """)


# ck_lams.cc
apps = Split("""
    ck_lams.cc
    ck_aout.cc
    ck_arinc.cc
    ck_calfile.cc
    extract2d.cc
    merge_verify.cc
    nidsmerge.cc
    dsm_server.cc
    dsm.cc
    statsproc.cc
    serial_test.cc
    sensor_sim.cc
    ck_serial.cc
    ck_config.cc
    ck_goes.cc
    ck_selector.cc
    sample_test.cc
    data_stats.cc
    data_dump.cc
    sync_dump.cc
    sync_server.cc
    status_listener.cc
    rserial.cc
    psi9116_sim.cc
    cat_nids.cc
    ck_a2d.cc
    ck_xml.cc
    isff/pdecode.cc
    isff/prep.cc
    raf/cvi_lv_test_in.cc
    raf/cvi_lv_test_out.cc
    utime.cc
    xml_dump.cc
    proj_configs.cc
    n_hdr_util.cc
    sensor_extract.cc
    sing.cc
""")

# apps which don't need, or want, the nidas libraries
nlapps = Split("""
    set_pcmcom8.c
    isff/set_emerald.c
    isff/emerald_dio.cc
""")

# apps which just need the nidas_util library
nuapps = Split("""
    gps_nmea_sysclock.cc
    garmin.cc
    tee_tty.cc
""")

# Note that we don't have to search the pthread, dl, xerces-c, cap, etc
# libraries, since they were searched when libnidas_dynld was built.
nodes = []
for i in apps + archapps:
    nodes += env.Program( source=i,
        LIBS= ['nidas_dynld'],
        LIBPATH = [env.Dir('../build_dynld')] + env['LIBPATH'])

# suppress linking against nidas libraries
for i in nlapps:
    nodes += env.Program(source=i,LIBS=[])

# link against nidas_util
for i in nuapps:
    nodes += env.Program(source=i,
        LIBS= ['nidas_util'],
        LIBPATH = [env.Dir('../build_util')] + env['LIBPATH'])

env.Install('$PREFIX/bin',nodes)

env.Clean(arch + '_install', [
    ('$PREFIX/bin/' + os.path.basename(File(l).path) for l in nodes)
    ])
