# -*- python -*-
## 2004, Copyright University Corporation for Atmospheric Research

import eol_scons.parseconfig as pc

##
##  Import the build environment.
##
Import('env')

env = env.Clone(tools = ['nidas'])
arch = env['ARCH']  # empty string for native builds
machs = env['MACHS']

env.NidasProgram('arl-ingest.cc')
env.NidasProgram('arinc_out.cc')
env.NidasProgram('ck_aout.cc')
env.NidasProgram('ck_calfile.cc')
env.NidasProgram('ck_xml.cc')
env.NidasProgram('data_dump.cc')
env.NidasProgram('data_stats.cc')
env.NidasProgram('dmd_mmat_test.cc')
env.NidasProgram('dsm_server.cc')
env.NidasProgram('dsm.cc')
env.NidasProgram('extract2d.cc')
env.NidasProgram('ir104.cc')
env.NidasProgram('lidar_vel.cc')
env.NidasProgram('merge_verify.cc')
env.NidasProgram('nidas_udp_relay.cc')
env.NidasProgram('nidsmerge.cc')
env.NidasProgram('n_hdr_util.cc')
env.NidasProgram('proj_configs.cc')
env.NidasProgram('rserial.cc')
env.NidasProgram('sensor_extract.cc')
env.NidasProgram('sensor_sim.cc')
env.NidasProgram('statsproc.cc')
env.NidasProgram('status_listener.cc')

sdenv = env.Clone()
SDSRCS = ['sync_dump.cc']
sdconf = sdenv.Configure()
# Explicitly disable protobuf build for now, since it isn't actually used
# and yet it causes memcheck errors in the sync_dump test.
if bool(False and
        sdconf.CheckLibWithHeader('protobuf', 'google/protobuf/stubs/common.h',
                                  'C++')):
    sdenv.Tool('protoc')
    sdenv['PROTOCPYTHONOUTDIR'] = None
    sdenv.Append(CPPDEFINES="SUPPORT_PROTOBUF_OUTPUT")
    SDSRCS += [sdenv.Protoc('syncrecord.proto')[1]]

if sdconf.CheckLibWithHeader('jsoncpp', 'jsoncpp/json/json.h', 'C++'):
    sdenv.Append(CPPDEFINES="SYNC_RECORD_JSON_OUTPUT")

# linux/i2c-dev.h contains only macros, no library needed.
# It exists on RedHat systems, but does not contain
# macros such as i2c_smbus_read_byte_data
has_i2c = False
if sdconf.CheckLibWithHeader('','linux/i2c-dev.h','C',
        'i2c_smbus_read_byte_data(0,0);'):
    has_i2c = True

sdenv = sdconf.Finish()
sdenv.Append(CPPFLAGS='-Wno-effc++')
sdenv.NidasProgram(SDSRCS)

env.NidasProgram('sync_server.cc')
env.NidasProgram('xml_dump.cc')
env.NidasProgram('isff/datasets.cc')

ncenv = env.Clone()
try:
    if pc.CheckConfig(env, 'pkg-config nc_server'):
        ncenv.MergeFlags('!pkg-config --cflags nc_server')
except OSerror:
    pass

ncenv.NidasProgram('isff/prep.cc')

# Programs which only use libnidas_util.so, not libnidas.
env.NidasUtilProgram('sing.cc')
env.NidasUtilProgram('tee_tty.cc')
if has_i2c:
    env.NidasUtilProgram('tee_i2c.cc')
    env.NidasUtilProgram('ublox.cc')

env.NidasUtilProgram('utime.cc')

if 'viper' in machs:
    # controls DIO pins on a Viper
    env.NidasProgram('viper_dio.cc')

if arch != '':
    # Programs which just do ioctls to NIDAS driver modules, and don't
    # otherwise use anything in the nidas libraries.
    env.NidasPlainProgram('set_pcmcom8.c')
    env.NidasPlainProgram('isff/set_emerald.c')
    env.NidasPlainProgram('isff/emerald_dio.cc')

    # nidas_util
    env.NidasUtilProgram('gps_nmea_sysclock.cc')
    env.NidasUtilProgram('garmin.cc')

# build auto_cal and config
if not env.has_key("BUILD_RAF") or env['BUILD_RAF']:
    SConscript("auto_cal/SConscript", exports=['env'])
    SConscript("config/SConscript", exports=['env'])

env.Alias('install', ['$PREFIX/bin'])
