# -*- python -*-
## 2004, Copyright University Corporation for Atmospheric Research

# This SConscript can be run two ways.  Normally it is part of a full build
# of the NIDAS source tree, using variant dirs to build into different
# paths for each machine architecture, and inheriting configuration
# settings and paths from the top-level SConstruct.  The other way builds
# the applications against an existing installation of NIDAS, by specifying
# the installation path in the NIDAS_PATH variable on the scons
# command-line and by running scons with this SConscript as the SConstruct
# file.  So the standalone build command looks like this:
#
#   scons -f SConscript NIDAS_PATH=/opt/nidas
#
# The top few lines of this file setup the Environment accordingly, while
# the rest of the file does not need to change.

import os
import eol_scons
import eol_scons.parseconfig as pc

def check_pkg_config(env, pkg):
    found = pc.ParseConfig(env, 'pkg-config %s --libs --cflags' % (pkg))
    print("pkg-config found for %s: %s" % (pkg, ["no", "yes"][int(found)]))
    return found

cpp11_source = """
#include <string>  //for converting data to_string
#include <future> //async function calls

int main(int argc, char** argv) {
std::string one = std::to_string(1);
return 0;
}
"""
def CheckCpp11(context):
    context.env.Append(CXXFLAGS='-std=c++11')
    context.Message('Checking for C++11 support...')
    result = context.TryCompile(cpp11_source, '.cc')
    context.Result(result)
    return result
 
custom_tests = {'CheckCpp11':CheckCpp11}


if not ARGUMENTS.get('NIDAS_PATH'):
    ##
    ##  Import the build environment.
    ##
    Import('env')
    env = env.Clone(tools = ['nidas'])
    arch = env['ARCH']  # empty string for native builds
    machs = env['MACHS']
else:
    env = Environment(tools=['default', 'nidas'])
    # We do this here because we don't get the setting from the top-level
    # SConstruct.
    pc.PassPkgConfigPath(env)
    arch = ''
    machs = []
    # If this path exists, then probably we're building on a Pi and it
    # needs to be on the path.
    xlibs = env.subst("${NIDAS_PATH}/lib/arm-linux-gnueabihf")
    if os.path.exists(xlibs):
        env.Append(LIBPATH=xlibs)

programs = Split("""
arl-ingest
arinc_out
ck_aout
ck_calfile
ck_xml
csat3_irga_config
data_dump
data_stats
dmd_mmat_test
dsm_auto_config
dsm_port_config
dsm_server
dsm
extract2d
extractDMT
ir104
lidar_vel
merge_verify
nidas_udp_relay
nidsmerge
n_hdr_util
pio
proj_configs
rserial
sensor_extract
sensor_sim
serstress
sing
statsproc
status_listener
sync_server
xml_dump
isff/datasets
""")

# For all these targets, wherever PREFIX is used, it should use
# ARCHPREFIX instead.
env['PREFIX'] = env.subst('$ARCHPREFIX')

# The NidasProgram method in the eol_scons nidas.py tool also adds the
# nidas libraries, but this tool includes any other dependencies like
# libftdi1 until the eol_scons tool can be updated.  Pass an explicit empty
# libs below to NidasProgram() avoid re-adding the nidas libraries.
env.Require('nidasdynld')

for prog in programs:
    env.Alias(prog, env.NidasProgram(prog+'.cc', libs=[]))

didbenv = env.Clone()
dbconf = didbenv.Configure(custom_tests=custom_tests)
if not dbconf.CheckCpp11():
    print("No C++11 support, data_influxdb will not be built.")
elif bool(not arch and
          check_pkg_config(didbenv, 'jsoncpp') and
          check_pkg_config(didbenv, 'libcurl')):
    print("C++11, jsoncpp, and libcurl found, building data_influxdb.")
    didbenv.AppendUnique(CXXFLAGS='-std=c++11')
    didbenv.Append(CXXFLAGS='-Wno-effc++')
    didb = didbenv.NidasProgram('data_influxdb.cc')
    didbenv.Alias('data_influxdb', didb)
dbconf.Finish()

sdenv = env.Clone()
# Remove nidas libraries before building configure tests, since they
# introduce dependencies on parts of nidas and scons tries to build them.
# They are added back later.  We can't use a fresh environment because it
# probably wouldn't get all the special compiler setup from the top level.
sdenv.Replace(LIBS=[])
sdconf = sdenv.Configure()
if not arch and check_pkg_config(sdenv, 'jsoncpp'):
    print("sync_dump will be built with json support")
    sdenv.Append(CPPDEFINES="SYNC_RECORD_JSON_OUTPUT")
else:
    print("sync_dump will be built without json support")
sdenv = sdconf.Finish()
sdenv.Append(CPPFLAGS='-Wno-effc++')
sdenv.Replace(LIBS=env['LIBS']+sdenv.get('LIBS', []))
env.Alias('sync_dump', sdenv.NidasProgram(['sync_dump.cc']))

ncenv = env.Clone()
try:
    if pc.CheckConfig(env, 'pkg-config nc_server'):
        ncenv.MergeFlags('!pkg-config --cflags nc_server')
except OSerror:
    pass

ncenv.NidasProgram('isff/prep.cc')

# Figure out if i2c is available and how to call it.  There are a few
# possibilities.
#
# Raspbian Jessie armhf: libi2c-dev 3.1.1 installs only linux/i2c-dev.h,
# which contains only macros and inline functions, no library needed.
#
# Raspbian Buster armhf: libi2c-dev 4.1 puts declarations i2c/smbus.h and
# definitions in libi2c.a
#
# At the moment ISFS only really needs i2c on Raspbian Jessie for the
# tee_i2c and ublox programs.  Since it appears that 4.1 removed
# I2C_SMBUS_I2C_BLOCK_MAX and i2cbuf, we'll just mark i2c unavailable
# unless it's a header-only version.
#
has_i2c = False
i2cenv = env.Clone()
i2cenv.Replace(LIBS=[])
i2cconf = i2cenv.Configure()
# check if i2c API has 3(old) or 4(new) arguments in
# i2c_smbus_read_i2c_block_data
if i2cconf.CheckLibWithHeader('i2c', 'i2c/smbus.h', 'C',
                              'i2c_smbus_read_i2c_block_data(0,0,0,0);'):
    print("ignoring i2c library, need header-only interface")
    has_i2c = False
elif i2cconf.CheckLibWithHeader('', 'linux/i2c-dev.h', 'C',
                                'i2c_smbus_read_i2c_block_data(0,0,0,0);'):
    i2cenv.Append(CPPDEFINES="I2C_HEADER_ONLY")
    has_i2c = True
elif i2cconf.CheckLibWithHeader('', 'linux/i2c-dev.h', 'C',
                                'i2c_smbus_read_i2c_block_data(0,0,0);'):
    i2cenv.Append(CPPDEFINES=["I2C_HEADER_ONLY", "OLD_I2C_API"])
    has_i2c = True
i2cenv = i2cconf.Finish()
i2cenv.Replace(LIBS=env['LIBS']+i2cenv.get('LIBS'))

# Programs which only use libnidas_util.so, not libnidas.
#env.NidasUtilProgram('sing.cc')
env.NidasUtilProgram('tee_tty.cc')
if has_i2c:
    env.Alias('tee_i2c', i2cenv.NidasUtilProgram('tee_i2c.cc', libs=[]))
    env.Alias('ublox', i2cenv.NidasUtilProgram('ublox.cc', libs=[]))

def ublox(env):
    """
    Tool to build against the ublox protocol header-only library.  At the
    moment it is always installed into /usr/local.
    """
    env.Append(CPPPATH=['/usr/local/include'])

Export('ublox')

# ubloxbin requires boost_asio, but as far as I can tell boost_asio is a
# header only library.
ubenv = env.Clone()
ubenv.Require(['boost_system', 'ublox'])
# boost_thread requires pthread, so someday boost_thread tool should be
# fixed to add that.
ubenv.Append(LIBS=['boost_thread', 'pthread'])
env.Alias('ubloxbin', ubenv.NidasProgram(['ubloxbin.cc']))

env.Alias('utime', env.NidasUtilProgram('utime.cc'))

if 'viper' in machs:
    # controls DIO pins on a Viper
    env.NidasProgram('viper_dio.cc')

if arch != '':
    # Programs which just do ioctls to NIDAS driver modules, and don't
    # otherwise use anything in the nidas libraries.
    env.NidasPlainProgram('set_pcmcom8.c')
    env.NidasPlainProgram('isff/set_emerald.c')
    env.NidasPlainProgram('isff/emerald_dio.cc')

    # nidas_util
    env.NidasUtilProgram('gps_nmea_sysclock.cc')
    env.NidasUtilProgram('garmin.cc')

# build auto_cal and config
if not env.has_key("BUILD_RAF") or env['BUILD_RAF']:
    SConscript("auto_cal/SConscript", exports=['env'])
    SConscript("config/SConscript", exports=['env'])

env.Alias('install', ['$PREFIX/bin'])
