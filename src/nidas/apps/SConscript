# -*- python -*-
# 2004, Copyright University Corporation for Atmospheric Research

# This SConscript can be run two ways.  Normally it is part of a full build
# of the NIDAS source tree, using variant dirs to build into different
# paths for each machine architecture, and inheriting configuration
# settings and paths from the top-level SConstruct.  The other way builds
# the applications against an existing installation of NIDAS, by specifying
# the installation path in the NIDAS_PATH variable on the scons
# command-line and by running scons with this SConscript as the SConstruct
# file.  So the standalone build command looks like this:
#
#   scons -f SConscript NIDAS_PATH=/opt/nidas
#
# The top few lines of this file setup the Environment accordingly, while
# the rest of the file does not need to change.

import os
import eol_scons
import eol_scons.parseconfig as pc
from SCons.Script import BoolVariable


def check_pkg_config(env, pkg):
    found = pc.ParseConfig(env, 'pkg-config %s --libs --cflags' % (pkg))
    print("pkg-config found for %s: %s" % (pkg, ["no", "yes"][int(found)]))
    return found


cpp14_source = """
#include <string>  //for converting data to_string
#include <future> //async function calls

int main(int argc, char** argv) {
std::string one = std::to_string(1);
return 0;
}
"""


def CheckCpp14(context):
    context.env.Append(CXXFLAGS='-std=c++14')
    context.Message('Checking for C++14 support...')
    result = context.TryCompile(cpp14_source, '.cc')
    context.Result(result)
    return result


custom_tests = {'CheckCpp14': CheckCpp14}


if not ARGUMENTS.get('NIDAS_PATH'):
    #
    #  Import the build environment.
    #
    Import('env')
    env = env.Clone(tools=['nidas'])
    arch = env['ARCH']  # empty string for native builds
    machs = env['MACHS']
else:
    env = Environment(tools=['default', 'nidas'])
    # We do this here because we don't get the setting from the top-level
    # SConstruct.
    pc.PassPkgConfigPath(env)
    arch = ''
    machs = []
    # If this path exists, then probably we're building on a Pi and it
    # needs to be on the path.
    xlibs = env.subst("${NIDAS_PATH}/lib/arm-linux-gnueabihf")
    if os.path.exists(xlibs):
        env.Append(LIBPATH=xlibs)

# Add jsoncpp to the environment for all now that core requires it.
env.AppendUnique(CPPDEFINES=['NIDAS_JSONCPP_ENABLED=1'])

programs = Split("""
arl-ingest
arinc_out
button_action
hardware_stats
ck_aout
ck_calfile
ck_xml
csat3_irga_config
data_dump
data_stats
dmd_mmat_test
dsm_auto_config
dsm_server
dsm
extract2d
extractDMT
ir104
lidar_vel
merge_verify
nidas_udp_relay
nidsmerge
n_hdr_util
pio
proj_configs
rserial
sensor_extract
sensor_sim
serstress
sing
statsproc
status_listener
sync_dump
sync_server
trh_load_cal
xml_dump
isff/datasets
""")

# For all these targets, wherever PREFIX is used, it should use
# ARCHPREFIX instead.
env['PREFIX'] = env.subst('$ARCHPREFIX')

# The NidasProgram method in the eol_scons nidas.py tool also adds the
# nidas libraries, but this tool includes any other dependencies like
# libftdi1 until the eol_scons tool can be updated.  Pass an explicit empty
# libs below to NidasProgram() avoid re-adding the nidas libraries.
env.Require('nidasdynld')

for prog in programs:
    env.Alias(prog, env.NidasProgram(prog+'.cc', libs=[]))

if env.get('ENABLE_FTDI_HARDWARE_INTERFACE'):
    hwenv = env.Clone()
    hwenv.Require('libftdi')
    hwenv.NidasPlainProgram('initFTDI.cc')
    hwenv.NidasPlainProgram('readFTDIpins.cc')

didbenv = env.Clone()
dbconf = didbenv.Configure(custom_tests=custom_tests)
if not dbconf.CheckCpp14():
    print("No C++14 support, data_influxdb will not be built.")
elif bool(not arch and check_pkg_config(didbenv, 'libcurl')):
    print("C++14 and libcurl found, building data_influxdb.")
    didbenv.AppendUnique(CXXFLAGS='-std=c++14')
    didbenv.Append(CXXFLAGS='-Wno-effc++')
    didb = didbenv.NidasProgram('data_influxdb.cc')
    didbenv.Alias('data_influxdb', didb)
dbconf.Finish()

ncenv = env.Clone()
try:
    if pc.CheckConfig(env, 'pkg-config nc_server'):
        ncenv.MergeFlags('!pkg-config --cflags nc_server')
except OSError:
    pass

ncenv.NidasProgram('isff/prep.cc')

# Programs which only use libnidas_util.so, not libnidas.
#env.NidasUtilProgram('sing.cc')
env.NidasUtilProgram('tee_tty.cc')


def ublox(env):
    """
    Tool to build against the ublox protocol header-only library.  At the
    moment it is always installed into /usr/local.
    """
    env.Append(CPPPATH=['/usr/local/include'])


Export('ublox')


variables = env.GlobalVariables()
variables.Add(BoolVariable('ENABLE_UBLOXBIN',
                           'Build ubloxbin utility.', 'on'))
variables.Update(env)

if env.get('ENABLE_UBLOXBIN'):
    # ubloxbin requires boost_asio, but as far as I can tell boost_asio is a
    # header only library.
    ubenv = env.Clone()
    ubenv.Append(CXXFLAGS='-Wno-effc++')
    ubenv['CXXFLAGS'].remove('-Weffc++')
    ubenv.Require(['boost_system', 'ublox'])
    # boost_thread requires pthread, so someday boost_thread tool should be
    # fixed to add that.
    ubenv.Append(LIBS=['boost_thread', 'pthread'])
    env.Alias('ubloxbin', ubenv.NidasProgram(['ubloxbin.cc']))

env.Alias('utime', env.NidasUtilProgram('utime.cc'))

if 'viper' in machs:
    # controls DIO pins on a Viper
    env.NidasProgram('viper_dio.cc')

if arch != '':
    # Programs which just do ioctls to NIDAS driver modules, and don't
    # otherwise use anything in the nidas libraries.
    env.NidasPlainProgram('set_pcmcom8.c')
    env.NidasPlainProgram('isff/set_emerald.c')
    env.NidasPlainProgram('isff/emerald_dio.cc')

    # nidas_util
    env.NidasUtilProgram('gps_nmea_sysclock.cc')
    env.NidasUtilProgram('garmin.cc')

# build auto_cal and config
if "BUILD_RAF" not in env or env['BUILD_RAF']:
    SConscript("auto_cal/SConscript", exports=['env'])
    SConscript("config/SConscript", exports=['env'])

env.Alias('install', ['$PREFIX/bin'])
