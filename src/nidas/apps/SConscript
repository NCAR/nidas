# -*- python -*-

##  Copyright 2005 UCAR, NCAR, All Rights Reserved
#
##
##  Import and clone the cross-build environment.
##
Import(['env','LIBNIDAS_UTIL','LIBNIDAS','LIBNIDAS_DYNLD'])
env = env.Clone()
arch = env['ARCH']

def buildprog(env,source,libs,libpath):
    node = env.Program(source=source,LIBS=libs,LIBPATH=libpath)
    inode = env.Install('$PREFIX/bin',node)
    env.Clean('install',inode)
    return node

# extract the paths to the nidas libraries, so that executables are built
# against the local tree.
nupath = LIBNIDAS_UTIL.Dir('')
ncpath = LIBNIDAS.Dir('')
ndpath = LIBNIDAS_DYNLD.Dir('')
libpath = [ nupath, ncpath, ndpath ]

# Specify the build for each executable, linking against a library only
# if necessary.
#
# For example, status_listener.cc is the only program below
# that directly references symbols in libxmlrpcpp.so, so only it needs
# xmlrpcpp in LIBS.  This actually has minimal effect, since libnidas.so
# references libxmlrpcpp.so, and so any executable linked against libnidas.so
# will require libxmlrpcpp.so.
#
# However, there are some executables, like set_pcmcom8, that are run
# early at boot time, for which we would like to minimize library dependencies.
#
# Also, programs like dsm and dsm_server, which dynamically load routines
# from nidas_dynld, don't need to be linked against it here. 
# By not specifying libnidas_dynld.so in the LIBS list for those programs,
# we can test that dynamic loading is working without a library having
# to be pre-linked.
#
# So rather than having several lists of source files, and separate builds
# for each list, it seems more straightforward to specify the
# build for each executable, using the above function to reduce the verbage
# somewhat.

nodes = []
nodes += buildprog(env,'ck_aout.cc',['nidas_util','nidas','nidas_dynld'],libpath)
nodes += buildprog(env,'ck_calfile.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'ck_xml.cc',['nidas_util','nidas','xerces-c'],libpath)
nodes += buildprog(env,'data_dump.cc',['nidas_util','nidas','nidas_dynld','xerces-c'],libpath)
nodes += buildprog(env,'data_stats.cc',['nidas_util','nidas','nidas_dynld','xerces-c'],libpath)
nodes += buildprog(env,'dmd_mmat_test.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'dsm_server.cc',['nidas_util','nidas','xerces-c'],libpath)
nodes += buildprog(env,'dsm.cc',['nidas_util','nidas','xerces-c'],libpath)
nodes += buildprog(env,'extract2d.cc',['nidas_util','nidas','nidas_dynld','xerces-c'],libpath)
nodes += buildprog(env,'ir104.cc',['nidas_util','nidas','nidas_dynld'],libpath)
nodes += buildprog(env,'lidar_vel.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'merge_verify.cc',['nidas_util','nidas','nidas_dynld'],libpath)
nodes += buildprog(env,'nidas_udp_relay.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'nidsmerge.cc',['nidas_util','nidas','nidas_dynld'],libpath)
nodes += buildprog(env,'n_hdr_util.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'proj_configs.cc',['nidas_util','nidas','xerces-c'],libpath)
nodes += buildprog(env,'rserial.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'sensor_extract.cc',['nidas_util','nidas','nidas_dynld'],libpath)
nodes += buildprog(env,'sensor_sim.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'sing.cc',['nidas_util','nidas'],libpath)
nodes += buildprog(env,'statsproc.cc',['nidas_util','nidas','nidas_dynld','xerces-c'],libpath)
nodes += buildprog(env,'status_listener.cc',['nidas_util','nidas','xerces-c','xmlrpcpp'],libpath)
nodes += buildprog(env,'sync_dump.cc',['nidas_util','nidas','nidas_dynld'],libpath)
nodes += buildprog(env,'sync_server.cc',['nidas_util','nidas','nidas_dynld','xerces-c'],libpath)
nodes += buildprog(env,'xml_dump.cc',['nidas_util','nidas','xerces-c'],libpath)
nodes += buildprog(env,'isff/ck_goes.cc',['nidas_util','nidas','nidas_dynld'],libpath)
nodes += buildprog(env,'isff/pdecode.cc',['nidas_util','nidas','nidas_dynld','xerces-c'],libpath)
nodes += buildprog(env,'isff/prep.cc',['nidas_util','nidas','nidas_dynld','xerces-c'],libpath)

nodes += buildprog(env,'set_pcmcom8.c',[],[])
nodes += buildprog(env,'isff/set_emerald.c',[],[])
nodes += buildprog(env,'isff/emerald_dio.cc',[],[])

nodes += buildprog(env,'tee_tty.cc',['nidas_util'],[nupath])
nodes += buildprog(env,'utime.cc',['nidas_util'],[nupath])

if arch == 'arm':
    nodes += buildprog(env,'viper_dio.cc',['nidas_util','nidas','nidas_dynld'],libpath)

if arch != 'x86':
    nodes += buildprog(env,'gps_nmea_sysclock.cc',['nidas_util'],[nupath])
    nodes += buildprog(env,'garmin.cc',['nidas_util'],[nupath])

# Export the nodes of built executables as a dictionary called NIDAS_APPS
apps = {}
for node in nodes:
    name = env.subst("${TARGET.filebase}", target=node)
    apps[name] = node
Export({'NIDAS_APPS':apps})

# build auto_cal
if arch == 'x86':
    SConscriptChdir(0)
    SConscript("auto_cal/SConscript",
        variant_dir='build_auto_cal',duplicate=1,exports={'env':env})
    # SConscript("config/SConscript",
    #     variant_dir='build_config',duplicate=1,exports={'env':env})

