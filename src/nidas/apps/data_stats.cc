/* -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4; -*- */
/* vim: set shiftwidth=4 softtabstop=4 expandtab: */
/*
 ********************************************************************
 ** NIDAS: NCAR In-situ Data Acquistion Software
 **
 ** 2005, Copyright University Corporation for Atmospheric Research
 **
 ** This program is free software; you can redistribute it and/or modify
 ** it under the terms of the GNU General Public License as published by
 ** the Free Software Foundation; either version 2 of the License, or
 ** (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU General Public License for more details.
 **
 ** The LICENSE.txt file accompanying this software contains
 ** a copy of the GNU General Public License. If it is not found,
 ** write to the Free Software Foundation, Inc.,
 ** 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 **
 ********************************************************************
*/

// #define _XOPEN_SOURCE	/* glibc2 needs this */

#include <ctime>

#include <nidas/core/FileSet.h>
#include <nidas/core/Socket.h>
#include <nidas/dynld/RawSampleInputStream.h>
#include <nidas/core/Project.h>
#include <nidas/core/XMLParser.h>
#include <nidas/core/SamplePipeline.h>
#include <nidas/core/DSMConfig.h>
#include <nidas/core/DSMSensor.h>
#include <nidas/core/Variable.h>
#include <nidas/core/NidasApp.h>
#include <nidas/core/BadSampleFilter.h>
#include <nidas/util/EOFException.h>
#include <nidas/util/Process.h>
#include <nidas/util/Logger.h>
#include <nidas/util/auto_ptr.h>
#include <nidas/util/util.h>

#include <set>
#include <map>
#include <deque>
#include <iostream>
#include <iomanip>
#include <sys/stat.h>

#include <unistd.h>

#ifndef NIDAS_JSONCPP_ENABLED
#define NIDAS_JSONCPP_ENABLED 1
#endif
#if NIDAS_JSONCPP_ENABLED
#include <json/json.h>
// Early json versions without StreamWriterBuilder also did not define a
// version symbol.
#ifndef JSONCPP_VERSION_STRING
#define NIDAS_JSONCPP_STREAMWRITER 0
#else
#define NIDAS_JSONCPP_STREAMWRITER 1
#endif
#endif

using namespace nidas::core;
using namespace nidas::dynld;
using namespace std;

namespace n_u = nidas::util;

namespace {
    inline std::string
    iso_format(const nidas::util::UTime& ut)
    {
        return ut.format(true, "%Y-%m-%dT%H:%M:%S.%3fZ");
    }
}

/**
 * SampleCounter accumulates samples and values for a particular sample stream.
 **/
class SampleCounter
{
public:
    /**
     * Create a SampleCounter for the given sample id @p sid.  If available,
     * pass the Sensor in @p sensor, and it will be used to collect metadata
     * about this sample stream and to set a header name.  If the SampleTag
     * for this sample is passed in @p stag, then it is used to store the
     * variable names for the sample values.
     **/
    SampleCounter(dsm_sample_id_t sid = 0, const DSMSensor* sensor = 0,
                  const SampleTag* stag = 0) :
        streamid(),
        sname(),
        id(sid),
        t1s(0),
        t2s(0),
        nsamps(0),
        minlens(0),
        maxlens(0),
        minDeltaTs(0),
        maxDeltaTs(0),
        sums(),
        nnans(),
        values(),
        rawmsg(),
        times(),
        varnames(),
        fullnames(),
        samples()
#if NIDAS_JSONCPP_ENABLED        
        ,header()
#endif
    {
        streamid = generateStreamId(sensor);
        if (sensor)
        {
            sname = sensor->getDSMConfig()->getName() + ":" +
                sensor->getDeviceName();
        }
        if (stag)
        {
            const std::vector<const Variable*>& variables = stag->getVariables();
            for (unsigned int i = 0; i < variables.size(); ++i)
            {
                // We need to keep track of two variable names, the fully
                // qualified 'name' and the short 'prefix' name.  The prefix
                // is unique within this stream, so it is used as the key,
                // whereas reports generated by callers want the full name.
                fullnames.push_back(variables[i]->getName());
                varnames.push_back(variables[i]->getPrefix());
            }
        }
        collectMetadata(sensor, stag);
    }

    /**
     * Format the sensor name or variable names for this SampleCounter into
     * a comma-separated list, abbreviated to a shortened form unless @p
     * allnames is true.  If this is a raw counter, meaning no variables,
     * then use the sensor name.  The fully-qualified variable names are
     * used in the header line to be compatible with historical behavior,
     * but maybe someday this can change.
     **/
    std::string
    getHeaderLine(bool allnames)
    {
        if (varnames.empty())
            return sname;
        string varname = fullnames[0];
        for (unsigned int i = 1; allnames && i < fullnames.size(); ++i)
        {
            varname += "," + fullnames[i];
        }
        if (!allnames && fullnames.size() > 1)
        {
            varname += ",...";
        }
        // Include device name when allnames enabled.
        if (allnames)
        {
            varname = "[" + sname + "] " + varname;
        }
        return varname;
    }

    /**
     * Reset the accumulated data without changing the sample tag information.
     **/
    void
    reset()
    {
        t1s = 0;
        t2s = 0;
        nsamps = 0;
        minlens = 0;
        maxlens = 0;
        minDeltaTs = 0;
        maxDeltaTs = 0;
        sums.clear();
        nnans.clear();
        values.clear();
        rawmsg.clear();
        times.clear();
    }

    bool
    receive(const Sample* samp) throw();

    void
    accumulateData(const Sample* samp);

    /**
     * Format the data from this SampleCounter and write it to the given
     * output stream @p outs.
     **/
    void
    printData(std::ostream& outs);

    /**
     * Generate a streamid for this SampleCounter.  The streamid is the
     * unique identifer for this stream of samples based on the available
     * metadata.
     **/
    std::string
    generateStreamId(const DSMSensor* sensor=0);

    void
    collectMetadata(const DSMSensor* sensor=0, const SampleTag* stag=0);

    /**
     * Recalculate all the statistics based on the current collection of
     * data.
     **/
    void
    updateStats(const nidas::util::UTime& start);

    void
    accumulateSample(const Sample* samp);

    string streamid;
    string sname;
    dsm_sample_id_t id;

    dsm_time_t t1s;
    dsm_time_t t2s;
    size_t nsamps;
    size_t minlens;
    size_t maxlens;
    int minDeltaTs;
    int maxDeltaTs;

    // Accumulate sums of each variable in the sample and counts of the
    // number of nans seen in each variable.  These are vectors keyed by
    // variable index.
    vector<float> sums;
    vector<int> nnans;
    vector<vector<float> > values;

    // For raw samples, build up a vector of the raw messages converted to strings.
    vector<std::string> rawmsg;

    // Collect the timestamps of all the samples also.
    vector<dsm_time_t> times;

    // Stash the variable names from the sample tag to identify the
    // variables in the accumulated data.  This can be used to map from
    // variable index in the sample to the key for the data maps.
    vector<string> varnames;
    vector<string> fullnames;

    // The buffer of samples from which statistics will be generated.
    typedef std::deque<const Sample*> sample_queue;
    sample_queue samples;

#if NIDAS_JSONCPP_ENABLED
    /**
     * Return a Json::Value node containing all the data in this SampleCounter.
     **/
    Json::Value
    jsonData();

    /**
     * Return a Json::Value containing just the header for this SampleClient.
     **/
    Json::Value
    jsonHeader()
    {
        return header;
    }

    // Store stream header metadata.
    Json::Value header;
#endif
};

namespace {
    // Copied from data_influxdb.cc, should probably be moved where it can
    // be shared.
    std::string
    id_to_string(unsigned int id)
    {
        ostringstream tostring;
        if (id >= 0x8000)
        {
            tostring << "0x" << hex << id;
        }
        else
        {
            tostring << id;
        }
        return tostring.str();
    }
}

std::string
SampleCounter::
generateStreamId(const DSMSensor* sensor)
{
    // From the full sample id we can at least get a DSM id and a SPS id.
    dsm_sample_id_t dsmid = GET_DSM_ID(id);
    dsm_sample_id_t spsid = GET_SPS_ID(id);

    // Use <project>.<dsmid>.<spsid>, for now.
    string projectname = "noproject";
    if (sensor)
    {
        const Project* project = sensor->getDSMConfig()->getProject();
        if (project)
            projectname = project->getName();
        // I would like to force this to lower case, but leave it for now.
        // I suppose technically ISFS project names are case-sensitive.
    }
    std::ostringstream out;
    // Hex for mote sample ids is just more useful for human inspection.
    out << projectname << "." << dsmid << "." << id_to_string(spsid);
    return out.str();
}

#if NIDAS_JSONCPP_ENABLED
/**
 * If the metadata string value is not empty, assign that
 * value to the json field named key.
 **/
std::string
assign_if_set(Json::Value& object, const std::string& key,
              const std::string& value)
{
    if (! value.empty())
        object[key] = value;
    return value;
}
#endif

void
SampleCounter::
collectMetadata(const DSMSensor* sensor, const SampleTag* stag)
{
#if NIDAS_JSONCPP_ENABLED
    header["streamid"] = streamid;
    // The header specifies a version in case the schema changes for either
    // the header itself or the data streams which reference it.
    header["version"] = "v0";
    header["dsmid"] = GET_DSM_ID(id);
    header["spsid"] = GET_SPS_ID(id);

    if (sensor)
    {
        const DSMConfig* dsm = sensor->getDSMConfig();
        const Project* project = dsm->getProject();
        string dsmname = dsm->getName();
        header["dsmname"] = dsmname;
        if (project)
            header["project"] = project->getName();
        const Site* site = sensor->getSite();
        if (site)
            header["site"] = site->getName();
        header["device"] = sensor->getDeviceName();
        // Some fields are not meaningful unless set.
        assign_if_set(header, "classname", sensor->getClassName());
        assign_if_set(header, "sensorcatalogname", sensor->getCatalogName());
        assign_if_set(header, "depth", sensor->getDepthString());
        assign_if_set(header, "height", sensor->getHeightString());
        assign_if_set(header, "location", sensor->getLocation());
    }
    if (stag)
    {
        double rate = stag->getRate();
        if (rate != 0)
            header["rate"] = rate;

        const std::vector<const Variable*>& variables = stag->getVariables();
        Json::Value& vmap = header["variables"];
        for (unsigned int i = 0; i < variables.size(); ++i)
        {
            const Variable& v = *variables[i];
            // The "short name" for a variable is known as the prefix, since
            // it is the very first part of the fully qualified long name.
            string vname = v.getPrefix();
            vmap[vname]["name"] = vname;
            // fullname is the fully qualified name, also known as the name.
            vmap[vname]["fullname"] = v.getName();
            vmap[vname]["longname"] = v.getLongName();
            vmap[vname]["units"] = v.getUnits();
        }
    }
#endif
}

void
SampleCounter::
updateStats(const nidas::util::UTime& start)
{
    // Reset all the current statistics and data, since that will all be
    // regenerated by replaying the samples.  Sure there might be more
    // efficient ways to do this, but this is a simpler and more robust
    // algorithm.
    reset();

    DLOG(("") << streamid << ": updateStats(" << iso_format(start) << ")");

    // Clear out any samples which precede the start time.  Start from the
    // end and erase from the first one which is too early, just in case a
    // sample with a future time might prevent any samples after it from
    // being removed.
    sample_queue::iterator it;
    dsm_time_t tstart(start.toUsecs());
    for (it = samples.end(); it != samples.begin(); )
    {
        --it;
        if ((*it)->getTimeTag() < tstart)
        {
            DLOG(("") << "erasing samples up to "
                << iso_format((*it)->getTimeTag()));
            sample_queue::iterator jt;
            for (jt = samples.begin(); jt != it+1; ++jt)
            {
                (*jt)->freeReference();
            }
            samples.erase(samples.begin(), it+1);
            break;
        }
    }
    if (samples.begin() == samples.end())
    {
        DLOG(("") << streamid << ": samples are empty after purge");
    }
    else
    {
        DLOG(("") << streamid << ": computing stats for samples from "
                << iso_format((*samples.begin())->getTimeTag())
                << " to "
                << iso_format((*samples.rbegin())->getTimeTag()));
    }
    
    for (it = samples.begin(); it != samples.end(); ++it)
    {
        accumulateSample(*it);
    }
}

bool
SampleCounter::
receive(const Sample* samp) throw()
{
    dsm_sample_id_t sampid = samp->getId();
    VLOG(("counting sample ") << nsamps << " for id "
         << NidasApp::getApplicationInstance()->formatId(sampid));
    if (sampid != id && nsamps == 0)
    {
        ILOG(("assigning received sample ID ")
             << NidasApp::getApplicationInstance()->formatId(sampid)
             << " in place of "
             << NidasApp::getApplicationInstance()->formatId(id));
        id = sampid;
    }
    else if (sampid != id)
    {
        // Worst case this would cause a message for every sample, but it
        // is rare enough to not be worth improving.
        ELOG(("sample ID ")
             << NidasApp::getApplicationInstance()->formatId(sampid)
             << "is being included in statistics for "
             << "samples with different ID: "
             << NidasApp::getApplicationInstance()->formatId(id));
    }
    samp->holdReference();
    samples.push_back(samp);
    return true;
}

    
void
SampleCounter::
accumulateSample(const Sample* samp)
{
    dsm_time_t sampt = samp->getTimeTag();
    if (nsamps == 0)
    {
        t1s = sampt;
        minDeltaTs = INT_MAX;
        maxDeltaTs = INT_MIN;
    }
    else
    {
        int deltaT = (sampt - t2s + USECS_PER_MSEC/2) / USECS_PER_MSEC;
        minDeltaTs = std::min(minDeltaTs, deltaT);
        maxDeltaTs = std::max(maxDeltaTs, deltaT);
    }
    times.push_back(sampt);
    t2s = sampt;

    size_t slen = samp->getDataByteLength();
    if (nsamps == 0)
    {
        minlens = slen;
        maxlens = slen;
    }
    else
    {
        minlens = std::min(minlens, slen);
        maxlens = std::max(maxlens, slen);
    }
    ++nsamps;

    accumulateData(samp);
}


void
SampleCounter::
accumulateData(const Sample* samp)
{
    if (samp->getType() == CHAR_ST)
    {
        const char* cp = (const char*)samp->getConstVoidDataPtr();
        size_t l = samp->getDataByteLength();
        if (l > 0 && cp[l-1] == '\0') l--;  // exclude trailing '\0'
            rawmsg.push_back(n_u::addBackslashSequences(string(cp,l)));
        return;
    }
    if (samp->getType() != FLOAT_ST && samp->getType() != DOUBLE_ST)
    {
        return;
    }
    unsigned int nvalues = samp->getDataLength();
    if (nvalues > sums.size())
    {
        sums.resize(nvalues);
        nnans.resize(nvalues);
        values.resize(nvalues);
    }
    for (unsigned int i = 0; i < nvalues; ++i)
    {
        double value = samp->getDataValue(i);
        values[i].push_back(value);
        if (isnan(value))
        {
            nnans[i] += 1;
        }
        else
        {
            sums[i] += value;
        }
    }
}


/**
 * CounterClient creates a SampleCounter for all the sample tags in a
 * given list of sensors, then it passes samples to the appropriate 
 * SampleCounter to be counted.
 **/
class CounterClient: public SampleClient 
{
public:

    /**
     * Construct a CounterClient, and create a SampleCounter for eacg of the
     * sample tags in the given sensors, if any.  Set @p singlemote to
     * expect only one mote for each sensor type.  When a wisard sensor
     * returns multiple sample tags with different mote IDs, samples will
     * only be expected from one of those tags.
     **/
    CounterClient(const list<DSMSensor*>& sensors, NidasApp& app,
                  bool singlemote, bool fullnames);

    virtual ~CounterClient() {}

    void flush() throw() {}

    bool receive(const Sample* samp) throw();

    void printResults(std::ostream& outs);

    void resetResults();

    void
    reportAll(bool all)
    {
        _reportall = all;
    }

    void
    reportData(bool data)
    {
        _reportdata = data;
    }

    /**
     * Provide direct access to a SampleCounter.
     **/
    SampleCounter*
    getSampleCounter(dsm_sample_id_t sid);

    vector<dsm_sample_id_t>
    getSampleIds();

private:

    typedef map<dsm_sample_id_t, SampleCounter> sample_map_t;

    /**
     * Find the SampleCounter for the given sample ID.  Wisard samples get
     * mapped to one sensor type, so we look for all of them.  Also, if
     * singlemote is enabled, search for wisard tags across all mote IDs
     * also, so only one mote ID will be mapped for each wisard sensor
     * type.
     **/
    sample_map_t::iterator
    findStats(dsm_sample_id_t sampid)
    {
        dsm_sample_id_t sid = sampid;
        sample_map_t::iterator it = _samples.end();
        if (sid & 0x8000)
        {
            sid = sid ^ (sid & 3);
            dsm_sample_id_t endid = sid + 4;
            VLOG(("searching from ")
                 << _app.formatId(sid) << " to " << _app.formatId(endid)
                 << " to match " << _app.formatId(sampid));
            while (sid < endid && it == _samples.end())
            {
                it = _samples.find(sid);
                unsigned int moteid = 0;
                while (_singlemote && it == _samples.end() && ++moteid <= 4)
                {
                    dsm_sample_id_t mid;
                    mid = (sid ^ (sid & 0xf00)) + (moteid * 0x100);
                    VLOG(("searching for alternate mote ID: ")
                         << _app.formatId(mid));
                    it = _samples.find(mid);
                }
                ++sid;
            }
        }
        else
        {
            it = _samples.find(sid);
        }
        return it;
    }

    sample_map_t _samples;

    bool _reportall;
    bool _reportdata;
    bool _singlemote;
    bool _fullnames;

    NidasApp& _app;
};

void
CounterClient::
resetResults()
{
    sample_map_t::iterator si;
    for (si = _samples.begin(); si != _samples.end(); ++si)
    {
        si->second.reset();
    }
}

SampleCounter*
CounterClient::
getSampleCounter(dsm_sample_id_t sid)
{
    sample_map_t::iterator it = findStats(sid);
    if (it == _samples.end())
        return 0;
    return &it->second;
}

vector<dsm_sample_id_t>
CounterClient::
getSampleIds()
{
    vector<dsm_sample_id_t> ids;
    sample_map_t::iterator si;
    for (si = _samples.begin(); si != _samples.end(); ++si)
    {
        ids.push_back(si->first);
    }
    return ids;
}



CounterClient::CounterClient(const list<DSMSensor*>& sensors, NidasApp& app,
                             bool singlemote, bool fullnames):
    _samples(),
    _reportall(false),
    _reportdata(false),
    _singlemote(singlemote),
    _fullnames(fullnames),
    _app(app)
{
    bool processed = app.processData();
    SampleMatcher& matcher = _app.sampleMatcher();
    list<DSMSensor*>::const_iterator si;
    for (si = sensors.begin(); si != sensors.end(); ++si)
    {
        // Create a SampleCounter for samples from the given sensors.
        DSMSensor* sensor = *si;
        string sname = sensor->getDSMConfig()->getName() + ":" +
            sensor->getDeviceName();

        // Stop with raw samples if processed not requested.
        if (! processed)
        {
            if (matcher.match(sensor->getId()))
            {
                dsm_sample_id_t sid = sensor->getId();
                DLOG(("adding raw sample: ") << _app.formatId(sid));
                SampleCounter stats(sid, sensor);
                _samples[stats.id] = stats;
            }
            continue;
        }

        SampleTagIterator ti = sensor->getSampleTagIterator();
        for ( ; ti.hasNext(); ) {
            const SampleTag* stag = ti.next();
            const std::vector<const Variable*>& variables = stag->getVariables();
            if (variables.size() > 0)
            {
                // As a special case for wisard sensors, mask the last two
                // bits of the IDs so all "sensor types" aka I2C addresses
                // are treated like the same kind of sample.  We use the
                // first such ID and then map any others to that one, since
                // in most cases only one such ID will ever appear for all
                // four possible "sensor types".  However, there is some
                // risk this could hide multiple sensor types appearing in
                // the stream.  We can warn for that later if it happens.
                // Since the wisard ID mapping is taken care of in
                // findStats(), here we just add the sensor if the ID does
                // not already have a stats entry.
                //
                // Note this just adds the first of possibly multiple
                // "sensor types" assigned to a sample.  The actual sample
                // IDs are not known until samples are received.  So that's
                // the point at which we can correct the ID so it is
                // accurate in the reports.  Likewise for mote IDs, since
                // samples for the same sensor type may have multiple
                // possible mote IDs to account for different mote IDs at
                // different DSMs.
                //
                // I suppose the other way to avoid redundant tags is to
                // compare the actual variable names, since those at least
                // should be unique.  The sample tags should be complete as
                // long as there is at least one sample tag for each
                // variable name.  That does not help for raw mode when no
                // project config is available, but it still might be a
                // more accurate and cleaner approach when there is a
                // project configuration.  Future implementation perhaps.
                dsm_sample_id_t sid = stag->getId();
                if (! matcher.match(sid))
                {
                    continue;
                }
                sample_map_t::iterator it = findStats(sid);
                if (it == _samples.end())
                {
                    DLOG(("adding processed sample: ") << _app.formatId(sid));
                    SampleCounter pstats(sid, sensor, stag);
                    _samples[pstats.id] = pstats;
                }
            }
        }
    }
}

bool CounterClient::receive(const Sample* samp) throw()
{
    dsm_sample_id_t sampid = samp->getId();
    if (! _app.sampleMatcher().match(sampid))
    {
        return false;
    }
    VLOG(("received and accepted sample ") << _app.formatId(sampid));
    sample_map_t::iterator it = findStats(sampid);
    if (it == _samples.end())
    {
        // When there is no header from which to gather samples ahead of
        // time, just add a SampleCounter instance for any new raw sample
        // that arrives.
        DLOG(("creating counter for sample id ") << _app.formatId(sampid));
        SampleCounter ss(sampid);
        _samples[sampid] = ss;
        it = findStats(sampid);
    }
    return it->second.receive(samp);
}


namespace
{
    /**
     * Compute the number of digits of space required to display
     * @p value in decimal.
     **/
    inline int
    ndigits(double value)
    {
        return (int)ceil(log10(value));
    }

    struct check_valid
    {
        double _value;
        bool _valid;

        check_valid(double value, bool valid) :
            _value(value),
            _valid(valid)
        {
        }            

        inline std::ostream&
        to_stream(std::ostream& outs) const
        {
            if (_valid)
            {
                outs << _value;
            }
            else
            {
                outs << floatNAN;
            }
            return outs;
        }
    };

    inline std::ostream&
    operator<<(std::ostream& outs, const check_valid& cv)
    {
        return cv.to_stream(outs);
    }
}



void CounterClient::printResults(std::ostream& outs)
{
    size_t maxnamelen = 6;
    int lenpow[2] = {5,5};
    int dtlog10[2] = {7,7};

    sample_map_t::iterator si;
    for (si = _samples.begin(); si != _samples.end(); ++si)
    {
        SampleCounter &ss = si->second;
        if (ss.nsamps == 0 && !_reportall)
            continue;
        string name = ss.getHeaderLine(_fullnames);
        maxnamelen = std::max(maxnamelen, name.length());
        if (ss.nsamps >= 1)
        {
            lenpow[0] = std::max(lenpow[0], ndigits(ss.minlens)+1);
            lenpow[1] = std::max(lenpow[1], ndigits(ss.maxlens)+1);
        }
        // Skip min/max stats which will be printed as missing if there are
        // not at least two samples.
        if (ss.nsamps >= 2)
        {
            int dt = abs(ss.minDeltaTs);
            dtlog10[0] = std::max(dtlog10[0], ndigits(dt+1)+2);
            dt = ss.maxDeltaTs;
            dtlog10[1] = std::max(dtlog10[1], ndigits(dt+1)+2);
        }
    }
        
    // Truncate maxnamelen when fullnames is in effect.
    if (_fullnames)
    {
        maxnamelen = 0;
    }

    struct tm tm;
    char tstr[64];
    outs << left << setw(maxnamelen) << (maxnamelen > 0 ? "sensor" : "")
         << right
         << "  dsm sampid    nsamps |------- start -------|  |------ end -----|"
         << "    rate"
         << setw(dtlog10[0] + dtlog10[1]) << " minMaxDT(sec)"
         << setw(lenpow[0] + lenpow[1]) << " minMaxLen"
         << endl;
    
    for (si = _samples.begin(); si != _samples.end(); ++si)
    {
        SampleCounter& ss = si->second;
        if (ss.nsamps == 0 && !_reportall)
            continue;

        string t1str;
        string t2str;
        if (ss.nsamps > 0)
        {
            time_t ut = ss.t1s / USECS_PER_SEC;
            gmtime_r(&ut,&tm);
            strftime(tstr,sizeof(tstr),"%Y %m %d %H:%M:%S",&tm);
            int msec = (int)(ss.t1s % USECS_PER_SEC) / USECS_PER_MSEC;
            sprintf(tstr + strlen(tstr),".%03d",msec);
            t1str = tstr;
            ut = ss.t2s / USECS_PER_SEC;
            gmtime_r(&ut,&tm);
            strftime(tstr,sizeof(tstr),"%m %d %H:%M:%S",&tm);
            msec = (int)(ss.t2s % USECS_PER_SEC) / USECS_PER_MSEC;
            sprintf(tstr + strlen(tstr),".%03d",msec);
            t2str = tstr;
        }
        else
        {
            t1str = string((size_t)23, '*');
            t2str = string((size_t)18, '*');
        }

        // Put long variable names on a header line before statistics.
        string name = ss.getHeaderLine(_fullnames);
        if (_fullnames)
        {
            outs << left << name << endl;
        }

        outs << left << setw(maxnamelen) << (maxnamelen ? name : "")
             << right << ' ' << setw(4) << GET_DSM_ID(ss.id) << ' ';
        NidasApp* app = NidasApp::getApplicationInstance();
        app->formatSampleId(outs, ss.id);

        double rate = double(ss.nsamps-1) /
            (double(ss.t2s - ss.t1s) / USECS_PER_SEC);
        outs << setw(9) << ss.nsamps << ' '
             << t1str << "  " << t2str << ' '
             << fixed << setw(7) << setprecision(2)
             << check_valid(rate, bool(ss.nsamps > 1))
             << setw(dtlog10[0]) << setprecision(3)
             << check_valid((double)ss.minDeltaTs / MSECS_PER_SEC, (ss.nsamps > 1))
             << setw(dtlog10[1]) << setprecision(3)
             << check_valid((float)ss.maxDeltaTs / MSECS_PER_SEC, (ss.nsamps > 1))
             << setprecision(0)
             << setw(lenpow[0]) << check_valid(ss.minlens, (ss.nsamps > 0))
             << setw(lenpow[1]) << check_valid(ss.maxlens, (ss.nsamps > 0))
             << endl;

        if (_reportdata){
            ss.printData(outs);
        }
    }
}


void
SampleCounter::
printData(std::ostream& outs)
{
    // No samples, no data to print.
    if (nsamps == 0)
    {
        return;
    }
    // Print the last raw data message, if there were any.
    if (rawmsg.size() > 0)
    {
        outs << " " << *rawmsg.rbegin() << endl;
    }
    size_t nwidth = 8;
    outs.unsetf(std::ios::fixed);
    outs << setprecision(3) << fixed;

    // Deliberately choose the short variable name when printing data, to
    // make the output more compact, and since the sensor header should
    // provide the necessary context to differentiate variable names.
    size_t maxname = 0;
    for (unsigned int i = 0; i < varnames.size(); ++i)
    {
        maxname = std::max(maxname, varnames[i].length());
    }
    int nfields = std::max((size_t)2, 80 / (maxname+2+nwidth));

    for (unsigned int i = 0; i < sums.size(); ++i)
    {
        if (i > 0 && i % nfields == 0)
        {
            outs << endl;
        }
        string varname;
        if (i < varnames.size())
        {
            varname = varnames[i];
        }
        outs << " " << setw(maxname) << right << varname << "=" << left;
        outs << setw(nwidth);
        int nvalues = nsamps - nnans[i];
        if (nvalues == 0)
        {
            outs << string(nwidth, '*');
        }
        else
        {
            outs << sums[i]/nvalues;
        }
        if (nvalues && nnans[i] > 0)
        {
            outs << "(*" << nnans[i] << " NaN*)";
        }
    }
    outs << endl;
}

#if NIDAS_JSONCPP_ENABLED
Json::Value
SampleCounter::
jsonData()
{
    Json::Value data;

    data["streamid"] = streamid;

    // If there are no variables and no samples, do not bother with any
    // other fields.
    if (varnames.size() == 0 || nsamps == 0)
    {
        return data;
    }

    for (unsigned int i = 0; i < varnames.size(); ++i)
    {
        Json::Value jvalues(Json::arrayValue);
        for (unsigned int j = 0; j < values[i].size(); ++j)
        {
            // jsoncpp on jessie does not convert nan to null, and nan is
            // not valid json.
            float& value = values[i][j];
            if (std::isnan(value))
            {
                jvalues.append(Json::Value());
            }
            else
            {
                jvalues.append(value);
            }
        }
        data[varnames[i]] = jvalues;
    }
    Json::Value jtimes(Json::arrayValue);
    for (unsigned int i = 0; i < times.size(); ++i)
    {
        nidas::util::UTime ut(times[i]);
        jtimes.append(iso_format(ut));
    }
    data["time"] = jtimes;
    return data;
}
#endif

class DataStats
{
public:
    DataStats();

    ~DataStats() {}

    int run();

    void readHeader(SampleInputStream& sis);

    void readSamples(SampleInputStream& sis);

    int parseRunstring(int argc, char** argv);

    static int main(int argc, char** argv);

    int usage(const char* argv0);

    bool
    reportsExhausted(int nreports=-1)
    {
        // Just to avoid the unused warning, while allowing _nreports to be
        // incremented with a prefix increment operator in the call to this
        // method.
        if (nreports > -1)
            _nreports = nreports;
        return (_count > 0 && _nreports > _count);
    }

    void
    writeResults(CounterClient& counter);

    static void handleSignal(int signum);

private:
    static const int DEFAULT_PORT = 30000;

    static bool _alarm;
    bool _realtime;
    n_u::UTime _period_start;
    n_u::UTime _period_end;
    int _count;
    int _period;
    int _update;
    int _nreports;

    NidasApp app;
    NidasAppArg Period;
    NidasAppArg Update;
    NidasAppArg Count;
    // Type of report to generate:
    //
    // All - show all samples, received or not
    // Missing - show only missing samples
    // Compact - report only one line for a site with no samples for any sensors
    // Received - show only received samples, the default
    NidasAppArg AllSamples;

    // Show averaged data or raw messages for each report.
    NidasAppArg ShowData;

    NidasAppArg SingleMote;
    NidasAppArg Fullnames;
    BadSampleFilterArg FilterArg;
    NidasAppArg JsonOutput;

#if NIDAS_JSONCPP_ENABLED
#if !NIDAS_JSONCPP_STREAMWRITER
    n_u::auto_ptr<Json::StyledStreamWriter> streamWriter;
    n_u::auto_ptr<Json::StyledStreamWriter> headerWriter;

    void
    createJsonWriters()
    {
        if (! streamWriter.get())
        {
            Json::StyledStreamWriter* sw = new Json::StyledStreamWriter("");
            // Can't set precision in the old StyledStreamWriter.
            streamWriter.reset(sw);

            Json::StyledStreamWriter* hw = new Json::StyledStreamWriter("  ");
            headerWriter.reset(hw);
        }
    }
#else
    n_u::auto_ptr<Json::StreamWriter> streamWriter;
    n_u::auto_ptr<Json::StreamWriter> headerWriter;

    void
    createJsonWriters()
    {
        if (! streamWriter.get())
        {
            Json::StreamWriterBuilder builder;
            builder.settings_["indentation"] = "";
            // This is just a guess at a reasonable value.  The goal is to make
            // the output a little more human readable and concise.
            builder.settings_["precision"] = 5;
            streamWriter.reset(builder.newStreamWriter());

            builder.settings_["indentation"] = "  ";
            headerWriter.reset(builder.newStreamWriter());
        }
    }
#endif
#endif
};


bool DataStats::_alarm(false);


void
DataStats::handleSignal(int signum)
{
    // The NidasApp handler sets interrupted before calling this handler,
    // so clear that if this is just the interval alarm.
    if (signum == SIGALRM)
    {
        NidasApp::setInterrupted(false);
        _alarm = true;
    }
}


DataStats::DataStats():
    _realtime(false),
    _period_start(time_t(0)),
    _period_end(time_t(0)),
    _count(1), _period(0), _update(0), _nreports(0),
    app("data_stats"),
    Period("-P,--period", "<seconds>",
           "Compute statistics over the given number of seconds.\n"
           "Defaults to the update period, if that is specified.", "0"),
    Update("-U,--update", "<seconds>",
           "Update the rolling statistics at the given update interval.\n"
           "Defaults to the sample period, if that is specified.\n"
           "For example, '--period 60 --update 5' computes statistics\n"
           "every 5 seconds over the last 60 seconds of data", "0"),
    Count("-n,--count", "<count>",
          "When --period specified, generate <count> reports.\n"
          "Use a count of zero to continue reports until interrupted.", "1"),
    AllSamples("-a,--all", "",
               "Show statistics for all sample IDs, including those for which "
               "no samples are received."),
    ShowData("-D,--data", "",
             "Print data for each sensor, either the last received message\n"
             "for raw samples, or data values averaged over the recording\n"
             "period for processed samples."),
    SingleMote("--onemote", "",
               "Expect each wisard sensor type to come from a single mote,\n"
               "so mote IDs are not differentiated in sample tags for the same\n"
               "type of sensor.  If there are two motes on a DSM, then any\n"
               "sensor duplication will report a warning, including Vmote."),
    Fullnames("-F,--fullnames", "",
              "Report all the variable names and the device name for each\n"
              "for each sensor."),
    FilterArg(),
    JsonOutput("--json", "<path>",
               "Write json stream headers to the given file path.\n"
               "The json file contains an object which maps\n"
               "each streamid to the header object for that stream.\n"
               "The header contains stream metadata and a dictionary of\n"
               "variables.  The sample data will be written to stdout as a\n"
               "newline-separated json stream, where each json line is\n"
               "an object with fields for each variable set to an array\n"
               "of values.  The 'streamid' in the data object relates to\n"
               "the header with that streamid.")
#if NIDAS_JSONCPP_ENABLED
    ,streamWriter(),
    headerWriter()
#endif
{
    app.setApplicationInstance();
    app.setupSignals();
    app.enableArguments(app.XmlHeaderFile | app.loggingArgs() |
                        app.SampleRanges | app.FormatHexId |
                        app.FormatSampleId | app.ProcessData |
                        app.Version | app.InputFiles | FilterArg |
                        app.Help | Period | Update | Count |
                        AllSamples | ShowData | SingleMote | Fullnames);
#if NIDAS_JSONCPP_ENABLED
    app.enableArguments(JsonOutput);
#endif               
    app.InputFiles.allowFiles = true;
    app.InputFiles.allowSockets = true;
    app.InputFiles.setDefaultInput("sock:localhost", DEFAULT_PORT);
}


int DataStats::parseRunstring(int argc, char** argv)
{
    // Setup a default log scheme which will get replaced if any logging is
    // configured on the command line.
    n_u::Logger* logger = n_u::Logger::getInstance();
    n_u::LogConfig lc("notice");
    logger->setScheme(logger->getScheme("default").addConfig(lc));

    try {
        ArgVector args = app.parseArgs(argc, argv);
        if (app.helpRequested())
        {
            return usage(argv[0]);
        }
        _period = Period.asInt();
        _update = Update.asInt();
        _count = Count.asInt();

        if (_period < 0 || _update < 0)
        {
            throw NidasAppException("period or update cannot be negative.");
        }
        if (_period > 0 && _update == 0)
        {
            _update = _period;
        }
        if (_update > 0 && _period == 0)
        {
            _period = _update;
        }
        app.parseInputs(args);
    }
    catch (NidasAppException& ex)
    {
        std::cerr << ex.what() << std::endl;
        return 1;
    }
    return 0;
}

int DataStats::usage(const char* argv0)
{
    cerr <<
        "Usage: " << argv0 << " [options] [inputURL] ...\n";
    cerr <<
        "Standard options:\n"
         << app.usage() <<
        "Examples:\n" <<
        argv0 << " xxx.dat yyy.dat\n" <<
        argv0 << " file:/tmp/xxx.dat file:/tmp/yyy.dat\n" <<
        argv0 << " -p -x ads3.xml sock:hyper:30000\n" <<
        argv0 << " --period 60 --update 5 -a -p -D -F" << endl;
    return 1;
}

int DataStats::main(int argc, char** argv)
{
    DataStats stats;
    int result;
    if (! (result = stats.parseRunstring(argc, argv)))
    {
        try {
            result = stats.run();
        }
        catch (n_u::Exception& e)
        {
            cerr << e.what() << endl;
            XMLImplementation::terminate(); // ok to terminate() twice
            result = 1;
        }
    }
    return result;
}

class AutoProject
{
public:
    AutoProject() { Project::getInstance(); }
    ~AutoProject() { Project::destroyInstance(); }
};


void
DataStats::
readHeader(SampleInputStream& sis)
{
    // Loop over the header read until it is read or the periods expire.
    // Since the header is not sent until there's a sample to send, if
    // there are no samples we could block in readInputHeader() waiting for
    // the header and never get to the readSamples() loop.
    bool header_read = false;
    _nreports = 0;
    while (!header_read && !app.interrupted() &&
           !reportsExhausted(++_nreports))
    {
        _alarm = false;
        if (_realtime)
            alarm(_update);
        try {
            sis.readInputHeader();
            header_read = true;
            // Reading the header does not count as a report cycle.
            --_nreports;
        }
        catch (n_u::IOException& e)
        {
            DLOG(("") << e.what() << " (errno=" << e.getErrno() << ")");
            if (e.getErrno() != ERESTART && e.getErrno() != EINTR)
                throw;
        }
        if (_realtime)
            alarm(0);
        if (app.interrupted())
        {
            throw n_u::Exception("Interrupted while waiting for header.");
        }
        if (_alarm)
        {
            ostringstream outs;
            outs << "Header not received after " << _nreports
                 << " periods of " << _update << " seconds.";
            // Throw an exception if nreports exhausted.
            if (reportsExhausted())
            {
                throw n_u::Exception(outs.str());
            }
            else
            {
                cerr << outs.str() << endl;
            }
        }
    }
}


void
DataStats::
readSamples(SampleInputStream& sis)
{
    // Read samples until an alarm signals the end of a reporting period or
    // an interruption occurs.
    _alarm = false;
    if (_update > 0 && _realtime)
    {
        alarm(_update);
    }
    while (!_alarm && !app.interrupted())
    {
        try {
            sis.readSamples();
        }
        catch (n_u::IOException& e)
        {
            DLOG(("") << e.what() << " (errno=" << e.getErrno() << ")");
            if (e.getErrno() != ERESTART && e.getErrno() != EINTR)
                throw;
        }
    }
}


void
DataStats::
writeResults(CounterClient& counter)
{
    ILOG(("") << "computing stats from "
              << iso_format(_period_start) << " to "
              << iso_format(_period_end));
    // First tell all the counters to update their statistics for the
    // current time period.
    vector<dsm_sample_id_t> ids = counter.getSampleIds();
    for (unsigned int i = 0; i < ids.size(); ++i)
    {
        SampleCounter* stream = counter.getSampleCounter(ids[i]);
        stream->updateStats(_period_start);
    }

    // Print results to stdout unless json output specified.  For json
    // output, write the headers and data to a file, and stream the data to
    // stdout in line-separated json.
    if (!JsonOutput.specified())
    {
        counter.printResults(cout);
    }
#if NIDAS_JSONCPP_ENABLED
    else
    {
        vector<dsm_sample_id_t> ids = counter.getSampleIds();
        // Use the existence of the json writer to know if the headers have
        // been written yet, so they are only written the first time.
        if (!streamWriter.get())
        {
            createJsonWriters();
            ILOG(("writing json to ") << JsonOutput.getValue());
        }
        if (1)
        {
            // Create a json object which contains all the headers and all the
            // data for all the SampleCounter streams, then write it out.
            Json::Value root;
            Json::Value timeperiod(Json::arrayValue);
            timeperiod.append(iso_format(_period_start));
            timeperiod.append(iso_format(_period_end));
            root["stats"]["timeperiod"] = timeperiod;

            for (unsigned int i = 0; i < ids.size(); ++i)
            {
                SampleCounter* stream = counter.getSampleCounter(ids[i]);
                // Use a "stream" field in the top level object to provide a
                // "namespace" for stream objects.  Keeping "data" and
                // "stream" namespaces allows writing both into one file or
                // into different files, without modifying the schema
                // expected by consumers.
                root["stream"][stream->streamid] = stream->jsonHeader();
                // Rewriting the data every time seems excessive, but at the
                // moment it's an expedient way to provide both headers and
                // data in one file for web clients.  Later the data could
                // be written into a different file.  Also, it might be
                // possible for the set of headers to change as streams come
                // and go, so writing them all together means they are
                // always in sync and consistent.  Every data object will
                // have a corresponding stream header in the same file.
                root["data"][stream->streamid] = stream->jsonData();
            }
            std::ofstream json;
            json.open(JsonOutput.getValue().c_str());
#if !NIDAS_JSONCPP_STREAMWRITER
            headerWriter->write(json, root);
#else
            headerWriter->write(root, &json);
#endif
            json.close();
        }
        // Now stream the data to stdout.
        for (unsigned int i = 0; i < ids.size(); ++i)
        {
            SampleCounter* stream = counter.getSampleCounter(ids[i]);
            if (stream->nsamps || AllSamples.asBool())
            {
#if !NIDAS_JSONCPP_STREAMWRITER
                streamWriter->write(std::cout, stream->jsonData());
#else
                streamWriter->write(stream->jsonData(), &std::cout);
#endif
                std::cout << std::endl;
            }
        }
    }
#endif
    counter.resetResults();
}


int DataStats::run()
{
    int result = 0;

    AutoProject aproject;
    IOChannel* iochan = 0;

    if (app.dataFileNames().size() > 0)
    {
        nidas::core::FileSet* fset =
            nidas::core::FileSet::getFileSet(app.dataFileNames());
        iochan = fset->connect();
    }
    else
    {
        n_u::Socket* sock = new n_u::Socket(*app.socketAddress());
        iochan = new nidas::core::Socket(sock);
        _realtime = true;
    }

    SampleInputStream sis(iochan, app.processData());
    sis.setBadSampleFilter(FilterArg.getFilter());
    DLOG(("filter setting: ") << FilterArg.getFilter());

    if (_update > 0 && _realtime)
    {
        app.addSignal(SIGALRM, &DataStats::handleSignal, true);
    }
    readHeader(sis);
    const SampleInputHeader& header = sis.getInputHeader();

    list<DSMSensor*> allsensors;

    string xmlFileName = app.xmlHeaderFile();
    if (xmlFileName.length() == 0)
        xmlFileName = header.getConfigName();
    xmlFileName = n_u::Process::expandEnvVars(xmlFileName);

    struct stat statbuf;
    if (::stat(xmlFileName.c_str(), &statbuf) == 0 || app.processData())
    {
        n_u::auto_ptr<xercesc::DOMDocument>
            doc(parseXMLConfigFile(xmlFileName));

        Project::getInstance()->fromDOMElement(doc->getDocumentElement());

        DSMConfigIterator di = Project::getInstance()->getDSMConfigIterator();
        for ( ; di.hasNext(); )
        {
            const DSMConfig* dsm = di.next();
            const list<DSMSensor*>& sensors = dsm->getSensors();
            allsensors.insert(allsensors.end(),sensors.begin(),sensors.end());
        }
    }
    XMLImplementation::terminate();

    SamplePipeline pipeline;                                  
    CounterClient counter(allsensors, app, SingleMote.asBool(),
                          Fullnames.asBool());
    counter.reportAll(AllSamples.asBool());
    counter.reportData(ShowData.asBool());

    if (app.processData())
    {
        pipeline.setRealTime(false);                              
        pipeline.setRawSorterLength(0);                           
        pipeline.setProcSorterLength(0);                          

        list<DSMSensor*>::const_iterator si;
        for (si = allsensors.begin(); si != allsensors.end(); ++si) {
            DSMSensor* sensor = *si;
            sensor->init();
            //  1. inform the SampleInputStream of what SampleTags to expect
            sis.addSampleTag(sensor->getRawSampleTag());
        }
        // 2. connect the pipeline to the SampleInputStream.
        pipeline.connect(&sis);

        // 3. connect the client to the pipeline
        pipeline.getProcessedSampleSource()->addSampleClient(&counter);
    }
    else
    {
        sis.addSampleClient(&counter);
    }

    try
    {
        // If realtime, start the period clock now.
        if (_realtime)
            _period_start = nidas::util::UTime();
        if (_period > 0 && _realtime)
        {
            ILOG(("") << "... Collecting samples for "
                      << _period << " seconds, "
                      << "updating " << _update
                      << " seconds, " << iso_format(_period_start)
                      << " ...");
        }
        while (!app.interrupted() && !reportsExhausted(++_nreports))
        {
            readSamples(sis);
            if (_realtime)
            {
                // Make sure the stat period is never more than requested.
                _period_end = nidas::util::UTime();
            }
            if (_realtime && _period > 0)
            {
                if (_period_start.toSecs() + _period < _period_end.toSecs())
                    _period_start = _period_end - _period * USECS_PER_SEC;
            }
            writeResults(counter);
        }
    }
    catch (n_u::EOFException& e)
    {
        cerr << e.what() << endl;
        writeResults(counter);
    }
    catch (n_u::IOException& e)
    {
        if (app.processData())
        {
            pipeline.getProcessedSampleSource()->removeSampleClient(&counter);
            pipeline.disconnect(&sis);
            pipeline.interrupt();
            pipeline.join();
        }
        else
        {
            sis.removeSampleClient(&counter);
        }
        sis.close();
        writeResults(counter);
        throw(e);
    }
    if (app.processData())
    {
        pipeline.disconnect(&sis);
        pipeline.flush();
        pipeline.getProcessedSampleSource()->removeSampleClient(&counter);
    }
    else
    {
        sis.removeSampleClient(&counter);
    }
    sis.close();
    pipeline.interrupt();
    pipeline.join();
    return result;
}

int main(int argc, char** argv)
{
    return DataStats::main(argc, argv);
}
