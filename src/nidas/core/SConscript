# -*- python -*-
## 2004, Copyright University Corporation for Atmospheric Research

import os
import eol_scons.parseconfig as pc
from SCons.Script import BoolVariable

##
##  Import the build environment.
##
Import('env')
env = env.Clone(tools = ['nidas'])

arch = env['ARCH']  # empty string for native builds
targetArch=arch
if targetArch == "":
    targetArch="host"

def nidas_xmlrpcpp(env):
    # nidas tool includes xmlrpc tool, but we're linking
    # that in statically now, so pull out xmlrpc for arm cross builds
    arch = env['ARCH']
    if arch in ["armhf"]:
        # Force link xmlrpc.a.
        libpath = '/usr/lib/arm-linux-gnueabihf/libXmlRpcpp.a'
        env.Append(LIBS=[env.File(libpath)])
    else:
        env.Append(LIBS=['xmlrpcpp'])


def jsoncpp(env):
    found = pc.ParseConfig(env, 'pkg-config jsoncpp --libs --cflags')
    print("pkg-config found for jsoncpp: %s" % (["no", "yes"][int(found)]))


variables = env.GlobalVariables()
variables.Add(BoolVariable('ENABLE_FTDI_HARDWARE_INTERFACE',
                           'Enable FTDI hardware interface', 'on'))
variables.Update(env)

##
##  List of header files
##
headers = Split("""
    AdaptiveDespiker.h
    AsciiSscanf.h
    BadSampleFilter.h
    BluetoothRFCommSocketIODevice.h
    Bzip2FileSet.h
    CalFile.h
    CharacterSensor.h
    ConnectionInfo.h
    ConnectionRequester.h
    Datagrams.h
    DatagramSocket.h
    Datasets.h
    DerivedDataClient.h
    DerivedDataReader.h
    Dictionary.h
    DOMable.h
    DOMObjectFactory.h
    DSMCatalog.h
    DSMConfig.h
    DSMEngine.h
    DSMEngineIntf.h
    DSMSensor.h
    DSMServer.h
    DSMServerApp.h
    DSMServerIntf.h
    DSMService.h
    DynamicLoader.h
    FileSet.h
    FsMount.h
    HardwareInterface.h
    HeaderSource.h
    IOChannel.h
    IODevice.h
    IOStream.h
    LooperClient.h
    Looper.h
    McSocket.h
    McSocketUDP.h
    Metadata.h
    MultipleUDPSockets.h
    NearestResampler.h
    NearestResamplerAtRate.h
    NidasApp.h
    NidsIterators.h
    Parameter.h
    PhysConstants.h
    Polled.h
    PortConfig.h
    PortType.h
    Project.h
    ProjectConfigs.h
    Prompt.h
    RemoteSerialConnection.h
    RemoteSerialListener.h
    Resampler.h
    SampleArchiver.h
    SampleAverager.h
    SampleClient.h
    SampleClientList.h
    SampleClock.h
    Sample.h
    sample_type_traits.h
    SampleInput.h
    SampleInputHeader.h
    SampleIOProcessor.h
    SampleLengthException.h
    SampleMatcher.h
    SampleOutput.h
    SampleOutputRequestThread.h
    SampleParseException.h
    SamplePipeline.h
    SamplePool.h
    SampleBuffer.h
    SampleScanner.h
    SampleSorter.h
    SampleSource.h
    SampleSourceSupport.h
    SampleStats.h
    SampleTag.h
    SampleThread.h
    SensorCatalog.h
    SensorHandler.h
    SensorOpener.h
    SerialPortIODevice.h
    SerialSensor.h
    ServiceCatalog.h
    Site.h
    Socket.h
    SocketAddrs.h
    SocketIODevice.h
    TCPSocketIODevice.h
    UDPSocketIODevice.h
    ServerSocketIODevice.h
    SortedSampleSet.h
    StatusHandler.h
    StatusListener.h
    StatusThread.h
    TimetagAdjuster.h
    UnixIOChannel.h
    UnixIODevice.h
    Variable.h
    VariableConverter.h
    VariableIndex.h
    Version.h
    XDOM.h
    requestXMLConfig.h
    XMLConfigInput.h
    XMLConfigWriter.h
    XMLException.h
    XMLFdBinInputStream.h
    XMLFdFormatTarget.h
    XMLFdInputSource.h
    XMLParser.h
    XMLWriter.h
    XmlRpcThread.h
    XMLStringConverter.h
""")

# print(["headers="] + [str(h) for h in headers])

sources = Split("""
    AdaptiveDespiker.cc
    BadSampleFilter.cc
    BluetoothRFCommSocketIODevice.cc
    Bzip2FileSet.cc
    CalFile.cc
    CharacterSensor.cc
    DatagramSocket.cc
    Datasets.cc
    DerivedDataReader.cc
    Dictionary.cc
    DOMable.cc
    DOMObjectFactory.cc
    DSMCatalog.cc
    DSMConfig.cc
    DSMEngine.cc
    DSMEngineIntf.cc
    DSMSensor.cc
    DSMServer.cc
    DSMServerApp.cc
    DSMServerIntf.cc
    DSMService.cc
    DynamicLoader.cc
    FileSet.cc
    FsMount.cc
    HeaderSource.cc
    IOChannel.cc
    IOStream.cc
    Looper.cc
    McSocket.cc
    McSocketUDP.cc
    Metadata.cc
    MultipleUDPSockets.cc
    NearestResampler.cc
    NearestResamplerAtRate.cc
    NidasApp.cc
    NidsIterators.cc
    Parameter.cc
    PortConfig.cc
    PortType.cc
    Project.cc
    Prompt.cc
    ProjectConfigs.cc
    RemoteSerialConnection.cc
    RemoteSerialListener.cc
    SampleArchiver.cc
    SampleAverager.cc
    SampleClientList.cc
    SampleClock.cc
    SampleInputHeader.cc
    SampleIOProcessor.cc
    SampleMatcher.cc
    SampleOutput.cc
    SampleOutputRequestThread.cc
    SamplePipeline.cc
    SamplePool.cc
    SampleBuffer.cc
    SampleScanner.cc
    SampleSorter.cc
    SampleSourceSupport.cc
    SampleTag.cc
    SensorCatalog.cc
    SensorHandler.cc
    SensorOpener.cc
    SerialPortIODevice.cc
    SerialSensor.cc
    ServiceCatalog.cc
    Site.cc
    Socket.cc
    SocketIODevice.cc
    TCPSocketIODevice.cc
    UDPSocketIODevice.cc
    ServerSocketIODevice.cc
    StatusHandler.cc
    StatusListener.cc
    StatusThread.cc
    TimetagAdjuster.cc
    UnixIOChannel.cc
    UnixIODevice.cc
    Variable.cc
    VariableConverter.cc
    Version.cc
    requestXMLConfig.cc
    XMLConfigWriter.cc
    XMLException.cc
    XMLFdFormatTarget.cc
    XMLParser.cc
    XMLWriter.cc
    XmlRpcThread.cc
""")

# If the lex tool is not available, SCons just quits with a
# mysterioius error about "no attribute 'CXXFile'", so check for the
# tool explicitly and print a more useful error message.
if 'lex' not in env['TOOLS']:
    import SCons.Errors
    raise SCons.Errors.StopError("Flex (or some lex tool) must be installed.")

# Create AsciiSscanf.cc from the .ll lex source.
env.CXXFile(target='AsciiSscanf.cc',source='AsciiSscanf.ll')

shobjs = []

# Override CXXFLAGS when compiling AsciiSscanf.cc to turn off -Weffc++ warnings.
# Code generated by flex generates many warnigs.
shobjs += env.SharedObject('AsciiSscanf.cc',CXXFLAGS="-Wall -O2 -Wno-deprecated -std=c++11")

if env.get('ENABLE_VALGRIND'):
    shobjs += env.SharedObject('Sample.cc', 
                                 CPPDEFINES = env.get('CPPDEFINES', []) +
                                 ['ENABLE_VALGRIND'])
else:
    shobjs += env.SharedObject('Sample.cc')


def libusb1(env):
    # There may be a way to check and set both header and library in the
    # environment using Configure(), but I haven't checked...
    cfenv = env.Clone()
    cfenv.Replace(LIBS=[])
    conf = Configure(cfenv)
    conf.CheckLib('usb-1.0')
    cfenv = conf.Finish()
    env.Append(LIBS=cfenv.get('LIBS', []))
    # Fedora installs header into a subdirectory.
    usbpath = env.Dir("/usr/include/libusb-1.0").abspath
    if os.path.exists(usbpath):
        env.Append(CPPPATH=[usbpath])

def libftdi(env):
    # Force link libftdi.a.  Prepend rel path w/# to escape the confines of
    # scons root directory w/SConstruct.
    #libftdi = File('#../../libftdi/libftdi1-1.4/build-' + targetArch +
    #               '/src/libftdi1.a')
    cfenv = env.Clone()
    cfenv.Replace(LIBS=[])
    conf = Configure(cfenv)
    conf.CheckLib('ftdi1')
    cfenv = conf.Finish()
    env.Append(LIBS=cfenv.get('LIBS', []))
    # On Fedora, libftdi-devel installs headers under /usr/include/libftdi1.
    hdir = env.Dir("/usr/include/libftdi1").abspath
    if os.path.exists(hdir):
        env.Append(CPPPATH=[hdir])
    env.Require([libusb1])

Export('libftdi')


env.Require(['nidasutil', nidas_xmlrpcpp, jsoncpp])
env.Append(LIBS=['dl', 'xerces-c'])

# Build the ftdi hardware interface if enabled
enable_ftdi = env.get('ENABLE_FTDI_HARDWARE_INTERFACE')
if enable_ftdi:
    hwenv = env.Clone()
    hwenv.Append(CPPDEFINES=['ENABLE_FTDI_HARDWARE_INTERFACE'])
    hwenv.Require([libftdi])
    shobjs += hwenv.SharedObject("HardwareInterface.cc")
    shobjs += hwenv.SharedObject('HardwareInterfaceFTDI.cc')
else:
    shobjs += env.SharedObject("HardwareInterface.cc")

##
##  Build the libnidas library. Search other needed libraries.
##
lib = env.SharedLibrary3('nidas' , [sources] + shobjs)
libnidas_core = lib[0]

# Test SConscripts need the full path to the library to set LD_LIBRARY_PATH
Export({'LIBNIDAS' + arch: lib[0]})

##
## Install targets for libraries and headers.
##
nodes = []
nodes.extend(env.SharedLibrary3Install('$ARCHPREFIX', lib))
nodes.extend(env.Install('$ARCHPREFIX/include/nidas/core', headers))

Alias('install', nodes)
Clean('install', nodes)

def nidascore(env):
    env.Append(LIBS=[libnidas_core])
    # Technically only the jsoncpp library link is needed to link with
    # nidascore, and not the include flags, but this is simpler.
    env.Require(['nidasutil', nidas_xmlrpcpp, 'jsoncpp'])
    env.Append(LIBS=['dl', 'xerces-c'])
    if enable_ftdi:
        env.Append(LIBS=['ftdi1'])

Export('nidascore')
