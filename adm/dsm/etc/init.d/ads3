#! /bin/sh
#
#
# Aircraft Data System
#
# . /etc/default/rcS

# set -x

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DAEMON=dsm
NAME=dsm
DESC="dsm"

ruser=ads
server=192.168.184.1
adspath=/home/local/hiaper/ads3

modpath=/var/tmp/modules
libpath=/var/tmp/lib
dsmpath=/var/tmp

modconf=/etc/dsm_modules.conf
devdir=/dev	# default value if not found in $modconf

if [ ! -r $modconf ]; then
    echo "$modconf not found"
    exit 1
fi

#
# After modules are loaded, create any necessary symbolic
# links between any character files found on /var/tmp/dev and /dev
# Modules create their FIFOs on /var/tmp/dev in order to
# reduce the writes to flash. The modules create and delete
# the fifos on every module load/unload.
# User space code opens the FIFOs on /dev since that is the
# conventional place for them.
#

create_dev_symlinks() {
    devdir=`get_devdir`
    [ $devdir == /dev ] && return
    [ -d $devdir ] || mkdir -p $devdir
    for d in $devdir/*; do
	if [ -c $d ]; then
	    f=${d##*/}
	    if [ ! -L /dev/$f -o ! -e /dev/$f ]; then
		[ -L /dev/$f  -o -e /dev/$f ] && rm /dev/$f
		echo "doing ln -s $d /dev"
		ln -s $d /dev
	    fi
	fi
    done
}

# check if a module is loaded, if not insmod it
insmod_chk() {
	lsmod | fgrep -q $1 || insmod "$@"
}

# check if a module is loaded, if so rmmod it
rmmod_chk() {
	lsmod | fgrep -q $1 && rmmod $1
}

# return an array of module names:
#    the first word of each non-comment line in stdin
get_modules() {
    while read module rest_of_line; do
        # echo "${modline[*]}"
        echo "$module" | egrep -q "^ *$" && continue
        echo "$module" | egrep -q "^ *#" && continue
        echo "$module"
    done
}

# read stdin to get the modules and their options.
# Look for devdir option
get_devdir() {
    local devdir="/dev"
    while read -a modline; do
        echo "${modline[0]}" | egrep -q "^ *$" && continue
        echo "${modline[0]}" | egrep -q "^ *#" && continue

	# look for devdir option
	if echo "${modline[@]}" | fgrep -q "devdir"; then
	    for o in ${modline[*]}; do
		if echo "$o" | fgrep -q "devdir"; then
		    devdir=`echo "$o" | cut -f 2 -d =`
		fi
	    done
	fi
    done
    # [ -d $devdir ] || mkdir -p $devdir
    echo $devdir
}
# load the modules read from stdin. This can't use
# get_modules because it needs the whole line
load_modules() {
    # depmod
    while read -a modline; do
        echo "${modline[0]}" | egrep -q "^ *$" && continue
        echo "${modline[0]}" | egrep -q "^ *#" && continue
        insmod_chk "${modline[@]}"
    done
}

unload_modules() {
    # use tac (reverse cat) to read stdin backwards since we
    # want to unload the modules in the reverse order
    # modules=($(tac -| get_modules))
    # for m in ${modules[*]}; do
    #     rmmod_chk $m
    # done

    # unfortunately tac doesn't exist in busybox on embedded systems
    # so we'll go through the array backwards.
    modules=($(get_modules))
    for (( i=${#modules[*]}-1; i >= 0; i-- )); do
        # [ ${modules[$i]} == rtl ] && continue	# don't unload rtl.o
        rmmod_chk ${modules[$i]}
    done
}


#
# Connect to the NTP time server
#
# /usr/sbin/ntpdate server && hwclock --systonc

copy_modules() {
    [ -d $modpath ] || mkdir -p $modpath
    modules=($(get_modules))
    for m in ${modules[*]}; do
        [ $m == rtl ] && continue	# don't fetch rtl.o
	scp $ruser@$server:$adspath/dsm/modules/arm/$m.o $modpath
    done
}
copy_apps() {
        [ -d $libpath ] || mkdir -p $libpath
        [ -d $dsmpath/filters ] || mkdir -p $dsmpath/filters
        
	scp $ruser@$server:$adspath/dsm/class/arm/libDsm.so $libpath
	scp $ruser@$server:$adspath/dsm/src/arm/dsm $dsmpath
	scp $ruser@$server:$adspath/dsm/filters/*.cfg $dsmpath/filters
}

start_app() {
        cd $dsmpath
	# start-stop-daemon --start --quiet --pidfile /var/run/$NAME.pid \
	# 	-b --exec $DAEMON
	./dsm > /var/log/dsm.log 2>&1 &
}

stop_app() {
        # cd $dsmpath
	# start-stop-daemon --stop --quiet --pidfile /var/run/$NAME.pid \
 	# 	--exec $DAEMON
 	echo "sending HUP to dsm"
 	pkill -HUP dsm
 	i=0
 	while [ $i -lt 5 ]; do
	 	sleep 2
	 	pgrep dsm || break
		i=$((i+1))
 	done
 	if [ $i -eq 5 ]; then
	 	echo "doing kill -9"
	 	pkill -9 dsm
	fi
}


case "$1" in
  start)
	echo -n "Starting $DESC (fetch & load modules, fetch app, run app): "
	unload_modules < $modconf
        copy_modules < $modconf
	create_dev_symlinks < $modconf
        load_modules < $modconf
        copy_apps
        start_app
	echo "$NAME."
	;;
  stop)
	echo -n "Stopping $DESC: "
	stop_app
	echo "$NAME."
	;;
  restart)
	echo -n "Restart of $DESC app (does not reload modules): "
	stop_app
	sleep 5
	start_app
	echo "$NAME."
	;;
  load)
	echo -n "Load of $DESC modules: "
	create_dev_symlinks < $modconf
	load_modules < $modconf
	;;
  unload)
	echo -n "Unload of $DESC (stops app, unloads modules): "
	stop_app
	sleep 5
	unload_modules < $modconf
	;;
  reload)
	echo -n "Reload of $DESC (stops app, reloads modules): "
	stop_app
	sleep 5
	unload_modules < $modconf
	create_dev_symlinks < $modconf
	load_modules < $modconf
	;;
  refetch)
	echo -n "Refetch of $DESC (stops app, fetches app & lib, starts app): "
        stop_app
        copy_apps
	start_app
	;;
  refetch_all)
	echo -n "Refetch_all of $DESC (stops app, unloads mods, fetches all, starts app): "
        stop_app
	unload_modules < $modconf
	copy_modules < $modconf
	create_dev_symlinks < $modconf
	load_modules < $modconf
        copy_apps
	start_app
	;;
  *)
	N=/etc/init.d/$NAME
	echo "Usage: $N {start|stop|restart|load|unload|reload|refetch|refetch_all}" >&2
	exit 1
	;;
esac

exit 0

